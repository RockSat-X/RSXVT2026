#if TARGET_NAME_IS_SandboxNucleoH533RE
    enum UXARTHandle : u32
    {
        UXARTHandle_stlink,
    };
    static constexpr u32 UXARTHandle_COUNT = 1;
    #define UXARTx_ USART_
    #define NVICInterrupt_UXARTx_stlink NVICInterrupt_USART2
    static const struct { typeof(USART2) UXARTx; typeof(NVICInterrupt_USART2) NVICInterrupt_UXARTx; typeof(STPY_USART2_KERNEL_SOURCE) STPY_UXARTx_KERNEL_SOURCE; typeof(STPY_USART2_BAUD_DIVIDER) STPY_UXARTx_BAUD_DIVIDER; typeof((struct CMSISTuple) { &RCC->APB1LRSTR, CONCAT(RCC_, APB1LRSTR_USART2RST_Pos), CONCAT(RCC_, APB1LRSTR_USART2RST_Msk) }) UXARTx_RESET; typeof((struct CMSISTuple) { &RCC->APB1LENR, CONCAT(RCC_, APB1LENR_USART2EN_Pos), CONCAT(RCC_, APB1LENR_USART2EN_Msk) }) UXARTx_ENABLE; typeof((struct CMSISTuple) { &RCC->CCIPR1, CONCAT(RCC_, CCIPR1_USART2SEL_Pos), CONCAT(RCC_, CCIPR1_USART2SEL_Msk) }) UXARTx_KERNEL_SOURCE; typeof(UXARTMode_full_duplex) UXARTx_MODE; } UXART_TABLE[] =
        {
            [UXARTHandle_stlink] = { .UXARTx = USART2, .NVICInterrupt_UXARTx = NVICInterrupt_USART2, .STPY_UXARTx_KERNEL_SOURCE = STPY_USART2_KERNEL_SOURCE, .STPY_UXARTx_BAUD_DIVIDER = STPY_USART2_BAUD_DIVIDER, .UXARTx_RESET = (struct CMSISTuple) { &RCC->APB1LRSTR, CONCAT(RCC_, APB1LRSTR_USART2RST_Pos), CONCAT(RCC_, APB1LRSTR_USART2RST_Msk) }, .UXARTx_ENABLE = (struct CMSISTuple) { &RCC->APB1LENR, CONCAT(RCC_, APB1LENR_USART2EN_Pos), CONCAT(RCC_, APB1LENR_USART2EN_Msk) }, .UXARTx_KERNEL_SOURCE = (struct CMSISTuple) { &RCC->CCIPR1, CONCAT(RCC_, CCIPR1_USART2SEL_Pos), CONCAT(RCC_, CCIPR1_USART2SEL_Msk) }, .UXARTx_MODE = UXARTMode_full_duplex },
        };
    static void
    _UXART_driver_interrupt(enum UXARTHandle handle);
    INTERRUPT_USART2(void)
    {
        _UXART_driver_interrupt(UXARTHandle_stlink);
    }
#endif
#if TARGET_NAME_IS_DemoI2C
    enum UXARTHandle : u32
    {
        UXARTHandle_stlink,
    };
    static constexpr u32 UXARTHandle_COUNT = 1;
    #define UXARTx_ USART_
    #define NVICInterrupt_UXARTx_stlink NVICInterrupt_USART2
    static const struct { typeof(USART2) UXARTx; typeof(NVICInterrupt_USART2) NVICInterrupt_UXARTx; typeof(STPY_USART2_KERNEL_SOURCE) STPY_UXARTx_KERNEL_SOURCE; typeof(STPY_USART2_BAUD_DIVIDER) STPY_UXARTx_BAUD_DIVIDER; typeof((struct CMSISTuple) { &RCC->APB1LRSTR, CONCAT(RCC_, APB1LRSTR_USART2RST_Pos), CONCAT(RCC_, APB1LRSTR_USART2RST_Msk) }) UXARTx_RESET; typeof((struct CMSISTuple) { &RCC->APB1LENR, CONCAT(RCC_, APB1LENR_USART2EN_Pos), CONCAT(RCC_, APB1LENR_USART2EN_Msk) }) UXARTx_ENABLE; typeof((struct CMSISTuple) { &RCC->CCIPR1, CONCAT(RCC_, CCIPR1_USART2SEL_Pos), CONCAT(RCC_, CCIPR1_USART2SEL_Msk) }) UXARTx_KERNEL_SOURCE; typeof(UXARTMode_full_duplex) UXARTx_MODE; } UXART_TABLE[] =
        {
            [UXARTHandle_stlink] = { .UXARTx = USART2, .NVICInterrupt_UXARTx = NVICInterrupt_USART2, .STPY_UXARTx_KERNEL_SOURCE = STPY_USART2_KERNEL_SOURCE, .STPY_UXARTx_BAUD_DIVIDER = STPY_USART2_BAUD_DIVIDER, .UXARTx_RESET = (struct CMSISTuple) { &RCC->APB1LRSTR, CONCAT(RCC_, APB1LRSTR_USART2RST_Pos), CONCAT(RCC_, APB1LRSTR_USART2RST_Msk) }, .UXARTx_ENABLE = (struct CMSISTuple) { &RCC->APB1LENR, CONCAT(RCC_, APB1LENR_USART2EN_Pos), CONCAT(RCC_, APB1LENR_USART2EN_Msk) }, .UXARTx_KERNEL_SOURCE = (struct CMSISTuple) { &RCC->CCIPR1, CONCAT(RCC_, CCIPR1_USART2SEL_Pos), CONCAT(RCC_, CCIPR1_USART2SEL_Msk) }, .UXARTx_MODE = UXARTMode_full_duplex },
        };
    static void
    _UXART_driver_interrupt(enum UXARTHandle handle);
    INTERRUPT_USART2(void)
    {
        _UXART_driver_interrupt(UXARTHandle_stlink);
    }
#endif
#if TARGET_NAME_IS_DemoTimer
    enum UXARTHandle : u32
    {
        UXARTHandle_stlink,
    };
    static constexpr u32 UXARTHandle_COUNT = 1;
    #define UXARTx_ USART_
    #define NVICInterrupt_UXARTx_stlink NVICInterrupt_USART2
    static const struct { typeof(USART2) UXARTx; typeof(NVICInterrupt_USART2) NVICInterrupt_UXARTx; typeof(STPY_USART2_KERNEL_SOURCE) STPY_UXARTx_KERNEL_SOURCE; typeof(STPY_USART2_BAUD_DIVIDER) STPY_UXARTx_BAUD_DIVIDER; typeof((struct CMSISTuple) { &RCC->APB1LRSTR, CONCAT(RCC_, APB1LRSTR_USART2RST_Pos), CONCAT(RCC_, APB1LRSTR_USART2RST_Msk) }) UXARTx_RESET; typeof((struct CMSISTuple) { &RCC->APB1LENR, CONCAT(RCC_, APB1LENR_USART2EN_Pos), CONCAT(RCC_, APB1LENR_USART2EN_Msk) }) UXARTx_ENABLE; typeof((struct CMSISTuple) { &RCC->CCIPR1, CONCAT(RCC_, CCIPR1_USART2SEL_Pos), CONCAT(RCC_, CCIPR1_USART2SEL_Msk) }) UXARTx_KERNEL_SOURCE; typeof(UXARTMode_full_duplex) UXARTx_MODE; } UXART_TABLE[] =
        {
            [UXARTHandle_stlink] = { .UXARTx = USART2, .NVICInterrupt_UXARTx = NVICInterrupt_USART2, .STPY_UXARTx_KERNEL_SOURCE = STPY_USART2_KERNEL_SOURCE, .STPY_UXARTx_BAUD_DIVIDER = STPY_USART2_BAUD_DIVIDER, .UXARTx_RESET = (struct CMSISTuple) { &RCC->APB1LRSTR, CONCAT(RCC_, APB1LRSTR_USART2RST_Pos), CONCAT(RCC_, APB1LRSTR_USART2RST_Msk) }, .UXARTx_ENABLE = (struct CMSISTuple) { &RCC->APB1LENR, CONCAT(RCC_, APB1LENR_USART2EN_Pos), CONCAT(RCC_, APB1LENR_USART2EN_Msk) }, .UXARTx_KERNEL_SOURCE = (struct CMSISTuple) { &RCC->CCIPR1, CONCAT(RCC_, CCIPR1_USART2SEL_Pos), CONCAT(RCC_, CCIPR1_USART2SEL_Msk) }, .UXARTx_MODE = UXARTMode_full_duplex },
        };
    static void
    _UXART_driver_interrupt(enum UXARTHandle handle);
    INTERRUPT_USART2(void)
    {
        _UXART_driver_interrupt(UXARTHandle_stlink);
    }
#endif
#if TARGET_NAME_IS_DemoTimekeeping
    enum UXARTHandle : u32
    {
        UXARTHandle_stlink,
    };
    static constexpr u32 UXARTHandle_COUNT = 1;
    #define UXARTx_ USART_
    #define NVICInterrupt_UXARTx_stlink NVICInterrupt_USART2
    static const struct { typeof(USART2) UXARTx; typeof(NVICInterrupt_USART2) NVICInterrupt_UXARTx; typeof(STPY_USART2_KERNEL_SOURCE) STPY_UXARTx_KERNEL_SOURCE; typeof(STPY_USART2_BAUD_DIVIDER) STPY_UXARTx_BAUD_DIVIDER; typeof((struct CMSISTuple) { &RCC->APB1LRSTR, CONCAT(RCC_, APB1LRSTR_USART2RST_Pos), CONCAT(RCC_, APB1LRSTR_USART2RST_Msk) }) UXARTx_RESET; typeof((struct CMSISTuple) { &RCC->APB1LENR, CONCAT(RCC_, APB1LENR_USART2EN_Pos), CONCAT(RCC_, APB1LENR_USART2EN_Msk) }) UXARTx_ENABLE; typeof((struct CMSISTuple) { &RCC->CCIPR1, CONCAT(RCC_, CCIPR1_USART2SEL_Pos), CONCAT(RCC_, CCIPR1_USART2SEL_Msk) }) UXARTx_KERNEL_SOURCE; typeof(UXARTMode_full_duplex) UXARTx_MODE; } UXART_TABLE[] =
        {
            [UXARTHandle_stlink] = { .UXARTx = USART2, .NVICInterrupt_UXARTx = NVICInterrupt_USART2, .STPY_UXARTx_KERNEL_SOURCE = STPY_USART2_KERNEL_SOURCE, .STPY_UXARTx_BAUD_DIVIDER = STPY_USART2_BAUD_DIVIDER, .UXARTx_RESET = (struct CMSISTuple) { &RCC->APB1LRSTR, CONCAT(RCC_, APB1LRSTR_USART2RST_Pos), CONCAT(RCC_, APB1LRSTR_USART2RST_Msk) }, .UXARTx_ENABLE = (struct CMSISTuple) { &RCC->APB1LENR, CONCAT(RCC_, APB1LENR_USART2EN_Pos), CONCAT(RCC_, APB1LENR_USART2EN_Msk) }, .UXARTx_KERNEL_SOURCE = (struct CMSISTuple) { &RCC->CCIPR1, CONCAT(RCC_, CCIPR1_USART2SEL_Pos), CONCAT(RCC_, CCIPR1_USART2SEL_Msk) }, .UXARTx_MODE = UXARTMode_full_duplex },
        };
    static void
    _UXART_driver_interrupt(enum UXARTHandle handle);
    INTERRUPT_USART2(void)
    {
        _UXART_driver_interrupt(UXARTHandle_stlink);
    }
#endif
#if TARGET_NAME_IS_DemoSDMMC
    enum UXARTHandle : u32
    {
        UXARTHandle_stlink,
    };
    static constexpr u32 UXARTHandle_COUNT = 1;
    #define UXARTx_ USART_
    #define NVICInterrupt_UXARTx_stlink NVICInterrupt_USART2
    static const struct { typeof(USART2) UXARTx; typeof(NVICInterrupt_USART2) NVICInterrupt_UXARTx; typeof(STPY_USART2_KERNEL_SOURCE) STPY_UXARTx_KERNEL_SOURCE; typeof(STPY_USART2_BAUD_DIVIDER) STPY_UXARTx_BAUD_DIVIDER; typeof((struct CMSISTuple) { &RCC->APB1LRSTR, CONCAT(RCC_, APB1LRSTR_USART2RST_Pos), CONCAT(RCC_, APB1LRSTR_USART2RST_Msk) }) UXARTx_RESET; typeof((struct CMSISTuple) { &RCC->APB1LENR, CONCAT(RCC_, APB1LENR_USART2EN_Pos), CONCAT(RCC_, APB1LENR_USART2EN_Msk) }) UXARTx_ENABLE; typeof((struct CMSISTuple) { &RCC->CCIPR1, CONCAT(RCC_, CCIPR1_USART2SEL_Pos), CONCAT(RCC_, CCIPR1_USART2SEL_Msk) }) UXARTx_KERNEL_SOURCE; typeof(UXARTMode_full_duplex) UXARTx_MODE; } UXART_TABLE[] =
        {
            [UXARTHandle_stlink] = { .UXARTx = USART2, .NVICInterrupt_UXARTx = NVICInterrupt_USART2, .STPY_UXARTx_KERNEL_SOURCE = STPY_USART2_KERNEL_SOURCE, .STPY_UXARTx_BAUD_DIVIDER = STPY_USART2_BAUD_DIVIDER, .UXARTx_RESET = (struct CMSISTuple) { &RCC->APB1LRSTR, CONCAT(RCC_, APB1LRSTR_USART2RST_Pos), CONCAT(RCC_, APB1LRSTR_USART2RST_Msk) }, .UXARTx_ENABLE = (struct CMSISTuple) { &RCC->APB1LENR, CONCAT(RCC_, APB1LENR_USART2EN_Pos), CONCAT(RCC_, APB1LENR_USART2EN_Msk) }, .UXARTx_KERNEL_SOURCE = (struct CMSISTuple) { &RCC->CCIPR1, CONCAT(RCC_, CCIPR1_USART2SEL_Pos), CONCAT(RCC_, CCIPR1_USART2SEL_Msk) }, .UXARTx_MODE = UXARTMode_full_duplex },
        };
    static void
    _UXART_driver_interrupt(enum UXARTHandle handle);
    INTERRUPT_USART2(void)
    {
        _UXART_driver_interrupt(UXARTHandle_stlink);
    }
#endif
#if TARGET_NAME_IS_SensorShield
    enum UXARTHandle : u32
    {
        UXARTHandle_stlink,
    };
    static constexpr u32 UXARTHandle_COUNT = 1;
    #define UXARTx_ USART_
    #define NVICInterrupt_UXARTx_stlink NVICInterrupt_USART2
    static const struct { typeof(USART2) UXARTx; typeof(NVICInterrupt_USART2) NVICInterrupt_UXARTx; typeof(STPY_USART2_KERNEL_SOURCE) STPY_UXARTx_KERNEL_SOURCE; typeof(STPY_USART2_BAUD_DIVIDER) STPY_UXARTx_BAUD_DIVIDER; typeof((struct CMSISTuple) { &RCC->APB1LRSTR, CONCAT(RCC_, APB1LRSTR_USART2RST_Pos), CONCAT(RCC_, APB1LRSTR_USART2RST_Msk) }) UXARTx_RESET; typeof((struct CMSISTuple) { &RCC->APB1LENR, CONCAT(RCC_, APB1LENR_USART2EN_Pos), CONCAT(RCC_, APB1LENR_USART2EN_Msk) }) UXARTx_ENABLE; typeof((struct CMSISTuple) { &RCC->CCIPR1, CONCAT(RCC_, CCIPR1_USART2SEL_Pos), CONCAT(RCC_, CCIPR1_USART2SEL_Msk) }) UXARTx_KERNEL_SOURCE; typeof(UXARTMode_full_duplex) UXARTx_MODE; } UXART_TABLE[] =
        {
            [UXARTHandle_stlink] = { .UXARTx = USART2, .NVICInterrupt_UXARTx = NVICInterrupt_USART2, .STPY_UXARTx_KERNEL_SOURCE = STPY_USART2_KERNEL_SOURCE, .STPY_UXARTx_BAUD_DIVIDER = STPY_USART2_BAUD_DIVIDER, .UXARTx_RESET = (struct CMSISTuple) { &RCC->APB1LRSTR, CONCAT(RCC_, APB1LRSTR_USART2RST_Pos), CONCAT(RCC_, APB1LRSTR_USART2RST_Msk) }, .UXARTx_ENABLE = (struct CMSISTuple) { &RCC->APB1LENR, CONCAT(RCC_, APB1LENR_USART2EN_Pos), CONCAT(RCC_, APB1LENR_USART2EN_Msk) }, .UXARTx_KERNEL_SOURCE = (struct CMSISTuple) { &RCC->CCIPR1, CONCAT(RCC_, CCIPR1_USART2SEL_Pos), CONCAT(RCC_, CCIPR1_USART2SEL_Msk) }, .UXARTx_MODE = UXARTMode_full_duplex },
        };
    static void
    _UXART_driver_interrupt(enum UXARTHandle handle);
    INTERRUPT_USART2(void)
    {
        _UXART_driver_interrupt(UXARTHandle_stlink);
    }
#endif
#if TARGET_NAME_IS_MainFlightComputer
    #error Target 'MainFlightComputer' defines no handle for the 'UXART' driver.
#endif
#if TARGET_NAME_IS_MainFlightComputer_NUCLEO
    enum UXARTHandle : u32
    {
        UXARTHandle_stlink,
        UXARTHandle_vn100,
    };
    static constexpr u32 UXARTHandle_COUNT = 2;
    #define UXARTx_ USART_
    #define NVICInterrupt_UXARTx_stlink NVICInterrupt_USART2
    #define NVICInterrupt_UXARTx_vn100 NVICInterrupt_USART3
    static const struct { typeof(USART2) UXARTx; typeof(NVICInterrupt_USART2) NVICInterrupt_UXARTx; typeof(STPY_USART2_KERNEL_SOURCE) STPY_UXARTx_KERNEL_SOURCE; typeof(STPY_USART2_BAUD_DIVIDER) STPY_UXARTx_BAUD_DIVIDER; typeof((struct CMSISTuple) { &RCC->APB1LRSTR, CONCAT(RCC_, APB1LRSTR_USART2RST_Pos), CONCAT(RCC_, APB1LRSTR_USART2RST_Msk) }) UXARTx_RESET; typeof((struct CMSISTuple) { &RCC->APB1LENR, CONCAT(RCC_, APB1LENR_USART2EN_Pos), CONCAT(RCC_, APB1LENR_USART2EN_Msk) }) UXARTx_ENABLE; typeof((struct CMSISTuple) { &RCC->CCIPR1, CONCAT(RCC_, CCIPR1_USART2SEL_Pos), CONCAT(RCC_, CCIPR1_USART2SEL_Msk) }) UXARTx_KERNEL_SOURCE; typeof(UXARTMode_full_duplex) UXARTx_MODE; } UXART_TABLE[] =
        {
            [UXARTHandle_stlink] = { .UXARTx = USART2, .NVICInterrupt_UXARTx = NVICInterrupt_USART2, .STPY_UXARTx_KERNEL_SOURCE = STPY_USART2_KERNEL_SOURCE, .STPY_UXARTx_BAUD_DIVIDER = STPY_USART2_BAUD_DIVIDER, .UXARTx_RESET = (struct CMSISTuple) { &RCC->APB1LRSTR, CONCAT(RCC_, APB1LRSTR_USART2RST_Pos), CONCAT(RCC_, APB1LRSTR_USART2RST_Msk) }, .UXARTx_ENABLE = (struct CMSISTuple) { &RCC->APB1LENR, CONCAT(RCC_, APB1LENR_USART2EN_Pos), CONCAT(RCC_, APB1LENR_USART2EN_Msk) }, .UXARTx_KERNEL_SOURCE = (struct CMSISTuple) { &RCC->CCIPR1, CONCAT(RCC_, CCIPR1_USART2SEL_Pos), CONCAT(RCC_, CCIPR1_USART2SEL_Msk) }, .UXARTx_MODE = UXARTMode_full_duplex },
            [UXARTHandle_vn100] =  { .UXARTx = USART3, .NVICInterrupt_UXARTx = NVICInterrupt_USART3, .STPY_UXARTx_KERNEL_SOURCE = STPY_USART3_KERNEL_SOURCE, .STPY_UXARTx_BAUD_DIVIDER = STPY_USART3_BAUD_DIVIDER, .UXARTx_RESET = (struct CMSISTuple) { &RCC->APB1LRSTR, CONCAT(RCC_, APB1LRSTR_USART3RST_Pos), CONCAT(RCC_, APB1LRSTR_USART3RST_Msk) }, .UXARTx_ENABLE = (struct CMSISTuple) { &RCC->APB1LENR, CONCAT(RCC_, APB1LENR_USART3EN_Pos), CONCAT(RCC_, APB1LENR_USART3EN_Msk) }, .UXARTx_KERNEL_SOURCE = (struct CMSISTuple) { &RCC->CCIPR1, CONCAT(RCC_, CCIPR1_USART3SEL_Pos), CONCAT(RCC_, CCIPR1_USART3SEL_Msk) }, .UXARTx_MODE = UXARTMode_full_duplex },
        };
    static void
    _UXART_driver_interrupt(enum UXARTHandle handle);
    INTERRUPT_USART2(void)
    {
        _UXART_driver_interrupt(UXARTHandle_stlink);
    }
    INTERRUPT_USART3(void)
    {
        _UXART_driver_interrupt(UXARTHandle_vn100);
    }
#endif
#if TARGET_NAME_IS_VehicleFlightComputer_R1
    enum UXARTHandle : u32
    {
        UXARTHandle_stlink,
        UXARTHandle_stepper_uart,
        UXARTHandle_vn100_esp32,
    };
    static constexpr u32 UXARTHandle_COUNT = 3;
    #define UXARTx_ USART_
    #define NVICInterrupt_UXARTx_stlink NVICInterrupt_USART2
    #define NVICInterrupt_UXARTx_stepper_uart NVICInterrupt_USART1
    #define NVICInterrupt_UXARTx_vn100_esp32 NVICInterrupt_USART3
    static const struct { typeof(USART2) UXARTx; typeof(NVICInterrupt_USART2) NVICInterrupt_UXARTx; typeof(STPY_USART2_KERNEL_SOURCE) STPY_UXARTx_KERNEL_SOURCE; typeof(STPY_USART2_BAUD_DIVIDER) STPY_UXARTx_BAUD_DIVIDER; typeof((struct CMSISTuple) { &RCC->APB1LRSTR, CONCAT(RCC_, APB1LRSTR_USART2RST_Pos), CONCAT(RCC_, APB1LRSTR_USART2RST_Msk) }) UXARTx_RESET; typeof((struct CMSISTuple) { &RCC->APB1LENR, CONCAT(RCC_, APB1LENR_USART2EN_Pos), CONCAT(RCC_, APB1LENR_USART2EN_Msk) }) UXARTx_ENABLE; typeof((struct CMSISTuple) { &RCC->CCIPR1, CONCAT(RCC_, CCIPR1_USART2SEL_Pos), CONCAT(RCC_, CCIPR1_USART2SEL_Msk) }) UXARTx_KERNEL_SOURCE; typeof(UXARTMode_full_duplex) UXARTx_MODE; } UXART_TABLE[] =
        {
            [UXARTHandle_stlink] =       { .UXARTx = USART2, .NVICInterrupt_UXARTx = NVICInterrupt_USART2, .STPY_UXARTx_KERNEL_SOURCE = STPY_USART2_KERNEL_SOURCE, .STPY_UXARTx_BAUD_DIVIDER = STPY_USART2_BAUD_DIVIDER, .UXARTx_RESET = (struct CMSISTuple) { &RCC->APB1LRSTR, CONCAT(RCC_, APB1LRSTR_USART2RST_Pos), CONCAT(RCC_, APB1LRSTR_USART2RST_Msk) }, .UXARTx_ENABLE = (struct CMSISTuple) { &RCC->APB1LENR, CONCAT(RCC_, APB1LENR_USART2EN_Pos), CONCAT(RCC_, APB1LENR_USART2EN_Msk) }, .UXARTx_KERNEL_SOURCE = (struct CMSISTuple) { &RCC->CCIPR1, CONCAT(RCC_, CCIPR1_USART2SEL_Pos), CONCAT(RCC_, CCIPR1_USART2SEL_Msk) }, .UXARTx_MODE = UXARTMode_full_duplex },
            [UXARTHandle_stepper_uart] = { .UXARTx = USART1, .NVICInterrupt_UXARTx = NVICInterrupt_USART1, .STPY_UXARTx_KERNEL_SOURCE = STPY_USART1_KERNEL_SOURCE, .STPY_UXARTx_BAUD_DIVIDER = STPY_USART1_BAUD_DIVIDER, .UXARTx_RESET = (struct CMSISTuple) { &RCC->APB2RSTR, CONCAT(RCC_, APB2RSTR_USART1RST_Pos), CONCAT(RCC_, APB2RSTR_USART1RST_Msk) }   , .UXARTx_ENABLE = (struct CMSISTuple) { &RCC->APB2ENR, CONCAT(RCC_, APB2ENR_USART1EN_Pos), CONCAT(RCC_, APB2ENR_USART1EN_Msk) }   , .UXARTx_KERNEL_SOURCE = (struct CMSISTuple) { &RCC->CCIPR1, CONCAT(RCC_, CCIPR1_USART1SEL_Pos), CONCAT(RCC_, CCIPR1_USART1SEL_Msk) }, .UXARTx_MODE = UXARTMode_half_duplex },
            [UXARTHandle_vn100_esp32] =  { .UXARTx = USART3, .NVICInterrupt_UXARTx = NVICInterrupt_USART3, .STPY_UXARTx_KERNEL_SOURCE = STPY_USART3_KERNEL_SOURCE, .STPY_UXARTx_BAUD_DIVIDER = STPY_USART3_BAUD_DIVIDER, .UXARTx_RESET = (struct CMSISTuple) { &RCC->APB1LRSTR, CONCAT(RCC_, APB1LRSTR_USART3RST_Pos), CONCAT(RCC_, APB1LRSTR_USART3RST_Msk) }, .UXARTx_ENABLE = (struct CMSISTuple) { &RCC->APB1LENR, CONCAT(RCC_, APB1LENR_USART3EN_Pos), CONCAT(RCC_, APB1LENR_USART3EN_Msk) }, .UXARTx_KERNEL_SOURCE = (struct CMSISTuple) { &RCC->CCIPR1, CONCAT(RCC_, CCIPR1_USART3SEL_Pos), CONCAT(RCC_, CCIPR1_USART3SEL_Msk) }, .UXARTx_MODE = UXARTMode_full_duplex },
        };
    static void
    _UXART_driver_interrupt(enum UXARTHandle handle);
    INTERRUPT_USART2(void)
    {
        _UXART_driver_interrupt(UXARTHandle_stlink);
    }
    INTERRUPT_USART1(void)
    {
        _UXART_driver_interrupt(UXARTHandle_stepper_uart);
    }
    INTERRUPT_USART3(void)
    {
        _UXART_driver_interrupt(UXARTHandle_vn100_esp32);
    }
#endif
#if TARGET_NAME_IS_VehicleFlightComputer_R2
    #error Target 'VehicleFlightComputer_R2' defines no handle for the 'UXART' driver.
#endif
#if TARGET_NAME_IS_DebugBoard
    #error Target 'DebugBoard' defines no handle for the 'UXART' driver.
#endif
#if TARGET_NAME_IS_MainCameraSystem
    #error Target 'MainCameraSystem' defines no handle for the 'UXART' driver.
#endif
#if TARGET_NAME_IS_DemoOVCAM
    enum UXARTHandle : u32
    {
        UXARTHandle_stlink,
    };
    static constexpr u32 UXARTHandle_COUNT = 1;
    #define UXARTx_ USART_
    #define NVICInterrupt_UXARTx_stlink NVICInterrupt_USART2
    static const struct { typeof(USART2) UXARTx; typeof(NVICInterrupt_USART2) NVICInterrupt_UXARTx; typeof(STPY_USART2_KERNEL_SOURCE) STPY_UXARTx_KERNEL_SOURCE; typeof(STPY_USART2_BAUD_DIVIDER) STPY_UXARTx_BAUD_DIVIDER; typeof((struct CMSISTuple) { &RCC->APB1LRSTR, CONCAT(RCC_, APB1LRSTR_USART2RST_Pos), CONCAT(RCC_, APB1LRSTR_USART2RST_Msk) }) UXARTx_RESET; typeof((struct CMSISTuple) { &RCC->APB1LENR, CONCAT(RCC_, APB1LENR_USART2EN_Pos), CONCAT(RCC_, APB1LENR_USART2EN_Msk) }) UXARTx_ENABLE; typeof((struct CMSISTuple) { &RCC->CCIPR1, CONCAT(RCC_, CCIPR1_USART2SEL_Pos), CONCAT(RCC_, CCIPR1_USART2SEL_Msk) }) UXARTx_KERNEL_SOURCE; typeof(UXARTMode_full_duplex) UXARTx_MODE; } UXART_TABLE[] =
        {
            [UXARTHandle_stlink] = { .UXARTx = USART2, .NVICInterrupt_UXARTx = NVICInterrupt_USART2, .STPY_UXARTx_KERNEL_SOURCE = STPY_USART2_KERNEL_SOURCE, .STPY_UXARTx_BAUD_DIVIDER = STPY_USART2_BAUD_DIVIDER, .UXARTx_RESET = (struct CMSISTuple) { &RCC->APB1LRSTR, CONCAT(RCC_, APB1LRSTR_USART2RST_Pos), CONCAT(RCC_, APB1LRSTR_USART2RST_Msk) }, .UXARTx_ENABLE = (struct CMSISTuple) { &RCC->APB1LENR, CONCAT(RCC_, APB1LENR_USART2EN_Pos), CONCAT(RCC_, APB1LENR_USART2EN_Msk) }, .UXARTx_KERNEL_SOURCE = (struct CMSISTuple) { &RCC->CCIPR1, CONCAT(RCC_, CCIPR1_USART2SEL_Pos), CONCAT(RCC_, CCIPR1_USART2SEL_Msk) }, .UXARTx_MODE = UXARTMode_full_duplex },
        };
    static void
    _UXART_driver_interrupt(enum UXARTHandle handle);
    INTERRUPT_USART2(void)
    {
        _UXART_driver_interrupt(UXARTHandle_stlink);
    }
#endif
#if TARGET_NAME_IS_DemoAnalog
    enum UXARTHandle : u32
    {
        UXARTHandle_stlink,
    };
    static constexpr u32 UXARTHandle_COUNT = 1;
    #define UXARTx_ USART_
    #define NVICInterrupt_UXARTx_stlink NVICInterrupt_USART2
    static const struct { typeof(USART2) UXARTx; typeof(NVICInterrupt_USART2) NVICInterrupt_UXARTx; typeof(STPY_USART2_KERNEL_SOURCE) STPY_UXARTx_KERNEL_SOURCE; typeof(STPY_USART2_BAUD_DIVIDER) STPY_UXARTx_BAUD_DIVIDER; typeof((struct CMSISTuple) { &RCC->APB1LRSTR, CONCAT(RCC_, APB1LRSTR_USART2RST_Pos), CONCAT(RCC_, APB1LRSTR_USART2RST_Msk) }) UXARTx_RESET; typeof((struct CMSISTuple) { &RCC->APB1LENR, CONCAT(RCC_, APB1LENR_USART2EN_Pos), CONCAT(RCC_, APB1LENR_USART2EN_Msk) }) UXARTx_ENABLE; typeof((struct CMSISTuple) { &RCC->CCIPR1, CONCAT(RCC_, CCIPR1_USART2SEL_Pos), CONCAT(RCC_, CCIPR1_USART2SEL_Msk) }) UXARTx_KERNEL_SOURCE; typeof(UXARTMode_full_duplex) UXARTx_MODE; } UXART_TABLE[] =
        {
            [UXARTHandle_stlink] = { .UXARTx = USART2, .NVICInterrupt_UXARTx = NVICInterrupt_USART2, .STPY_UXARTx_KERNEL_SOURCE = STPY_USART2_KERNEL_SOURCE, .STPY_UXARTx_BAUD_DIVIDER = STPY_USART2_BAUD_DIVIDER, .UXARTx_RESET = (struct CMSISTuple) { &RCC->APB1LRSTR, CONCAT(RCC_, APB1LRSTR_USART2RST_Pos), CONCAT(RCC_, APB1LRSTR_USART2RST_Msk) }, .UXARTx_ENABLE = (struct CMSISTuple) { &RCC->APB1LENR, CONCAT(RCC_, APB1LENR_USART2EN_Pos), CONCAT(RCC_, APB1LENR_USART2EN_Msk) }, .UXARTx_KERNEL_SOURCE = (struct CMSISTuple) { &RCC->CCIPR1, CONCAT(RCC_, CCIPR1_USART2SEL_Pos), CONCAT(RCC_, CCIPR1_USART2SEL_Msk) }, .UXARTx_MODE = UXARTMode_full_duplex },
        };
    static void
    _UXART_driver_interrupt(enum UXARTHandle handle);
    INTERRUPT_USART2(void)
    {
        _UXART_driver_interrupt(UXARTHandle_stlink);
    }
#endif
#if TARGET_NAME_IS_TestESP32s
    enum UXARTHandle : u32
    {
        UXARTHandle_stlink,
        UXARTHandle_esp32,
    };
    static constexpr u32 UXARTHandle_COUNT = 2;
    #define UXARTx_ USART_
    #define NVICInterrupt_UXARTx_stlink NVICInterrupt_USART2
    #define NVICInterrupt_UXARTx_esp32 NVICInterrupt_USART3
    static const struct { typeof(USART2) UXARTx; typeof(NVICInterrupt_USART2) NVICInterrupt_UXARTx; typeof(STPY_USART2_KERNEL_SOURCE) STPY_UXARTx_KERNEL_SOURCE; typeof(STPY_USART2_BAUD_DIVIDER) STPY_UXARTx_BAUD_DIVIDER; typeof((struct CMSISTuple) { &RCC->APB1LRSTR, CONCAT(RCC_, APB1LRSTR_USART2RST_Pos), CONCAT(RCC_, APB1LRSTR_USART2RST_Msk) }) UXARTx_RESET; typeof((struct CMSISTuple) { &RCC->APB1LENR, CONCAT(RCC_, APB1LENR_USART2EN_Pos), CONCAT(RCC_, APB1LENR_USART2EN_Msk) }) UXARTx_ENABLE; typeof((struct CMSISTuple) { &RCC->CCIPR1, CONCAT(RCC_, CCIPR1_USART2SEL_Pos), CONCAT(RCC_, CCIPR1_USART2SEL_Msk) }) UXARTx_KERNEL_SOURCE; typeof(UXARTMode_full_duplex) UXARTx_MODE; } UXART_TABLE[] =
        {
            [UXARTHandle_stlink] = { .UXARTx = USART2, .NVICInterrupt_UXARTx = NVICInterrupt_USART2, .STPY_UXARTx_KERNEL_SOURCE = STPY_USART2_KERNEL_SOURCE, .STPY_UXARTx_BAUD_DIVIDER = STPY_USART2_BAUD_DIVIDER, .UXARTx_RESET = (struct CMSISTuple) { &RCC->APB1LRSTR, CONCAT(RCC_, APB1LRSTR_USART2RST_Pos), CONCAT(RCC_, APB1LRSTR_USART2RST_Msk) }, .UXARTx_ENABLE = (struct CMSISTuple) { &RCC->APB1LENR, CONCAT(RCC_, APB1LENR_USART2EN_Pos), CONCAT(RCC_, APB1LENR_USART2EN_Msk) }, .UXARTx_KERNEL_SOURCE = (struct CMSISTuple) { &RCC->CCIPR1, CONCAT(RCC_, CCIPR1_USART2SEL_Pos), CONCAT(RCC_, CCIPR1_USART2SEL_Msk) }, .UXARTx_MODE = UXARTMode_full_duplex },
            [UXARTHandle_esp32] =  { .UXARTx = USART3, .NVICInterrupt_UXARTx = NVICInterrupt_USART3, .STPY_UXARTx_KERNEL_SOURCE = STPY_USART3_KERNEL_SOURCE, .STPY_UXARTx_BAUD_DIVIDER = STPY_USART3_BAUD_DIVIDER, .UXARTx_RESET = (struct CMSISTuple) { &RCC->APB1LRSTR, CONCAT(RCC_, APB1LRSTR_USART3RST_Pos), CONCAT(RCC_, APB1LRSTR_USART3RST_Msk) }, .UXARTx_ENABLE = (struct CMSISTuple) { &RCC->APB1LENR, CONCAT(RCC_, APB1LENR_USART3EN_Pos), CONCAT(RCC_, APB1LENR_USART3EN_Msk) }, .UXARTx_KERNEL_SOURCE = (struct CMSISTuple) { &RCC->CCIPR1, CONCAT(RCC_, CCIPR1_USART3SEL_Pos), CONCAT(RCC_, CCIPR1_USART3SEL_Msk) }, .UXARTx_MODE = UXARTMode_full_duplex },
        };
    static void
    _UXART_driver_interrupt(enum UXARTHandle handle);
    INTERRUPT_USART2(void)
    {
        _UXART_driver_interrupt(UXARTHandle_stlink);
    }
    INTERRUPT_USART3(void)
    {
        _UXART_driver_interrupt(UXARTHandle_esp32);
    }
#endif
#undef _EXPAND_HANDLE
#define _EXPAND_HANDLE\
    if (!(0 <= handle && handle < UXARTHandle_COUNT))\
        panic;\
    auto const driver = &_UXART_drivers[handle];\
    auto const UXARTx = UXART_TABLE[handle].UXARTx;\
    auto const NVICInterrupt_UXARTx = UXART_TABLE[handle].NVICInterrupt_UXARTx;\
    auto const STPY_UXARTx_KERNEL_SOURCE = UXART_TABLE[handle].STPY_UXARTx_KERNEL_SOURCE;\
    auto const STPY_UXARTx_BAUD_DIVIDER = UXART_TABLE[handle].STPY_UXARTx_BAUD_DIVIDER;\
    auto const UXARTx_RESET = UXART_TABLE[handle].UXARTx_RESET;\
    auto const UXARTx_ENABLE = UXART_TABLE[handle].UXARTx_ENABLE;\
    auto const UXARTx_KERNEL_SOURCE = UXART_TABLE[handle].UXARTx_KERNEL_SOURCE;\
    auto const UXARTx_MODE = UXART_TABLE[handle].UXARTx_MODE;\

