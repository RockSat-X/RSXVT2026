#if TARGET_NAME_IS_SandboxNucleoH533RE
    #error Target 'SandboxNucleoH533RE' defines no handle for the 'SPI' driver.
#endif
#if TARGET_NAME_IS_DemoI2C
    #error Target 'DemoI2C' defines no handle for the 'SPI' driver.
#endif
#if TARGET_NAME_IS_DemoTimer
    #error Target 'DemoTimer' defines no handle for the 'SPI' driver.
#endif
#if TARGET_NAME_IS_DemoSPI
    enum SPIHandle : u32
    {
        SPIHandle_primary,
        SPIHandle_secondary,
    };
    static constexpr u32 SPIHandle_COUNT = 2;
    #define SPIx_ SPI_
    #define NVICInterrupt_SPIx_primary NVICInterrupt_SPI2
    #define NVICInterrupt_SPIx_secondary NVICInterrupt_SPI1
    static const struct { typeof(SPI2) SPIx; typeof(NVICInterrupt_SPI2) NVICInterrupt_SPIx; typeof(STPY_SPI2_KERNEL_SOURCE) STPY_SPIx_KERNEL_SOURCE; typeof(STPY_SPI2_BYPASS_DIVIDER) STPY_SPIx_BYPASS_DIVIDER; typeof(STPY_SPI2_DIVIDER) STPY_SPIx_DIVIDER; typeof((struct CMSISTuple) { &RCC->APB1LRSTR, CONCAT(RCC_, APB1LRSTR_SPI2RST_Pos), CONCAT(RCC_, APB1LRSTR_SPI2RST_Msk) }) SPIx_RESET; typeof((struct CMSISTuple) { &RCC->APB1LENR, CONCAT(RCC_, APB1LENR_SPI2EN_Pos), CONCAT(RCC_, APB1LENR_SPI2EN_Msk) }) SPIx_ENABLE; typeof((struct CMSISTuple) { &RCC->CCIPR3, CONCAT(RCC_, CCIPR3_SPI2SEL_Pos), CONCAT(RCC_, CCIPR3_SPI2SEL_Msk) }) SPIx_KERNEL_SOURCE; typeof(SPIRole_master) SPIx_ROLE; } SPI_TABLE[] =
        {
            [SPIHandle_primary] =   { .SPIx = SPI2, .NVICInterrupt_SPIx = NVICInterrupt_SPI2, .STPY_SPIx_KERNEL_SOURCE = STPY_SPI2_KERNEL_SOURCE, .STPY_SPIx_BYPASS_DIVIDER = STPY_SPI2_BYPASS_DIVIDER, .STPY_SPIx_DIVIDER = STPY_SPI2_DIVIDER, .SPIx_RESET = (struct CMSISTuple) { &RCC->APB1LRSTR, CONCAT(RCC_, APB1LRSTR_SPI2RST_Pos), CONCAT(RCC_, APB1LRSTR_SPI2RST_Msk) }, .SPIx_ENABLE = (struct CMSISTuple) { &RCC->APB1LENR, CONCAT(RCC_, APB1LENR_SPI2EN_Pos), CONCAT(RCC_, APB1LENR_SPI2EN_Msk) }, .SPIx_KERNEL_SOURCE = (struct CMSISTuple) { &RCC->CCIPR3, CONCAT(RCC_, CCIPR3_SPI2SEL_Pos), CONCAT(RCC_, CCIPR3_SPI2SEL_Msk) }, .SPIx_ROLE = SPIRole_master         },
            [SPIHandle_secondary] = { .SPIx = SPI1, .NVICInterrupt_SPIx = NVICInterrupt_SPI1, .STPY_SPIx_KERNEL_SOURCE = STPY_SPI1_KERNEL_SOURCE, .STPY_SPIx_BYPASS_DIVIDER = STPY_SPI1_BYPASS_DIVIDER, .STPY_SPIx_DIVIDER = STPY_SPI1_DIVIDER, .SPIx_RESET = (struct CMSISTuple) { &RCC->APB2RSTR, CONCAT(RCC_, APB2RSTR_SPI1RST_Pos), CONCAT(RCC_, APB2RSTR_SPI1RST_Msk) }   , .SPIx_ENABLE = (struct CMSISTuple) { &RCC->APB2ENR, CONCAT(RCC_, APB2ENR_SPI1EN_Pos), CONCAT(RCC_, APB2ENR_SPI1EN_Msk) }   , .SPIx_KERNEL_SOURCE = (struct CMSISTuple) { &RCC->CCIPR3, CONCAT(RCC_, CCIPR3_SPI1SEL_Pos), CONCAT(RCC_, CCIPR3_SPI1SEL_Msk) }, .SPIx_ROLE = SPIRole_slave_receiver },
        };
    static void
    _SPI_driver_interrupt(enum SPIHandle handle);
    INTERRUPT_SPI2(void)
    {
        _SPI_driver_interrupt(SPIHandle_primary);
    }
    INTERRUPT_SPI1(void)
    {
        _SPI_driver_interrupt(SPIHandle_secondary);
    }
#endif
#if TARGET_NAME_IS_DemoTimekeeping
    #error Target 'DemoTimekeeping' defines no handle for the 'SPI' driver.
#endif
#if TARGET_NAME_IS_DemoSDMMC
    #error Target 'DemoSDMMC' defines no handle for the 'SPI' driver.
#endif
#if TARGET_NAME_IS_SensorShield
    #error Target 'SensorShield' defines no handle for the 'SPI' driver.
#endif
#if TARGET_NAME_IS_MainFlightComputer
    #error Target 'MainFlightComputer' defines no handle for the 'SPI' driver.
#endif
#if TARGET_NAME_IS_MainFlightComputer_NUCLEO
    #error Target 'MainFlightComputer_NUCLEO' defines no handle for the 'SPI' driver.
#endif
#if TARGET_NAME_IS_VehicleFlightComputer_R1
    enum SPIHandle : u32
    {
        SPIHandle_openmv,
    };
    static constexpr u32 SPIHandle_COUNT = 1;
    #define SPIx_ SPI_
    #define NVICInterrupt_SPIx_openmv NVICInterrupt_SPI2
    static const struct { typeof(SPI2) SPIx; typeof(NVICInterrupt_SPI2) NVICInterrupt_SPIx; typeof(STPY_SPI2_KERNEL_SOURCE) STPY_SPIx_KERNEL_SOURCE; typeof(STPY_SPI2_BYPASS_DIVIDER) STPY_SPIx_BYPASS_DIVIDER; typeof(STPY_SPI2_DIVIDER) STPY_SPIx_DIVIDER; typeof((struct CMSISTuple) { &RCC->APB1LRSTR, CONCAT(RCC_, APB1LRSTR_SPI2RST_Pos), CONCAT(RCC_, APB1LRSTR_SPI2RST_Msk) }) SPIx_RESET; typeof((struct CMSISTuple) { &RCC->APB1LENR, CONCAT(RCC_, APB1LENR_SPI2EN_Pos), CONCAT(RCC_, APB1LENR_SPI2EN_Msk) }) SPIx_ENABLE; typeof((struct CMSISTuple) { &RCC->CCIPR3, CONCAT(RCC_, CCIPR3_SPI2SEL_Pos), CONCAT(RCC_, CCIPR3_SPI2SEL_Msk) }) SPIx_KERNEL_SOURCE; typeof(SPIRole_slave_receiver) SPIx_ROLE; } SPI_TABLE[] =
        {
            [SPIHandle_openmv] = { .SPIx = SPI2, .NVICInterrupt_SPIx = NVICInterrupt_SPI2, .STPY_SPIx_KERNEL_SOURCE = STPY_SPI2_KERNEL_SOURCE, .STPY_SPIx_BYPASS_DIVIDER = STPY_SPI2_BYPASS_DIVIDER, .STPY_SPIx_DIVIDER = STPY_SPI2_DIVIDER, .SPIx_RESET = (struct CMSISTuple) { &RCC->APB1LRSTR, CONCAT(RCC_, APB1LRSTR_SPI2RST_Pos), CONCAT(RCC_, APB1LRSTR_SPI2RST_Msk) }, .SPIx_ENABLE = (struct CMSISTuple) { &RCC->APB1LENR, CONCAT(RCC_, APB1LENR_SPI2EN_Pos), CONCAT(RCC_, APB1LENR_SPI2EN_Msk) }, .SPIx_KERNEL_SOURCE = (struct CMSISTuple) { &RCC->CCIPR3, CONCAT(RCC_, CCIPR3_SPI2SEL_Pos), CONCAT(RCC_, CCIPR3_SPI2SEL_Msk) }, .SPIx_ROLE = SPIRole_slave_receiver },
        };
    static void
    _SPI_driver_interrupt(enum SPIHandle handle);
    INTERRUPT_SPI2(void)
    {
        _SPI_driver_interrupt(SPIHandle_openmv);
    }
#endif
#if TARGET_NAME_IS_VehicleFlightComputer_R2
    #error Target 'VehicleFlightComputer_R2' defines no handle for the 'SPI' driver.
#endif
#if TARGET_NAME_IS_DebugBoard
    #error Target 'DebugBoard' defines no handle for the 'SPI' driver.
#endif
#if TARGET_NAME_IS_MainCameraSystem
    #error Target 'MainCameraSystem' defines no handle for the 'SPI' driver.
#endif
#if TARGET_NAME_IS_DemoOVCAM
    #error Target 'DemoOVCAM' defines no handle for the 'SPI' driver.
#endif
#if TARGET_NAME_IS_DemoAnalog
    #error Target 'DemoAnalog' defines no handle for the 'SPI' driver.
#endif
#if TARGET_NAME_IS_TestESP32s
    #error Target 'TestESP32s' defines no handle for the 'SPI' driver.
#endif
#undef _EXPAND_HANDLE
#define _EXPAND_HANDLE\
    if (!(0 <= handle && handle < SPIHandle_COUNT))\
        panic;\
    auto const driver = &_SPI_drivers[handle];\
    auto const SPIx = SPI_TABLE[handle].SPIx;\
    auto const NVICInterrupt_SPIx = SPI_TABLE[handle].NVICInterrupt_SPIx;\
    auto const STPY_SPIx_KERNEL_SOURCE = SPI_TABLE[handle].STPY_SPIx_KERNEL_SOURCE;\
    auto const STPY_SPIx_BYPASS_DIVIDER = SPI_TABLE[handle].STPY_SPIx_BYPASS_DIVIDER;\
    auto const STPY_SPIx_DIVIDER = SPI_TABLE[handle].STPY_SPIx_DIVIDER;\
    auto const SPIx_RESET = SPI_TABLE[handle].SPIx_RESET;\
    auto const SPIx_ENABLE = SPI_TABLE[handle].SPIx_ENABLE;\
    auto const SPIx_KERNEL_SOURCE = SPI_TABLE[handle].SPIx_KERNEL_SOURCE;\
    auto const SPIx_ROLE = SPI_TABLE[handle].SPIx_ROLE;\

