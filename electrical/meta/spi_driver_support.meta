#if TARGET_NAME_IS_SandboxNucleoH7S3L8
    #error Target "SandboxNucleoH7S3L8" cannot use the SPI driver without first specifying the peripheral instances to have handles for.
#endif
#if TARGET_NAME_IS_SandboxNucleoH533RE
    #error Target "SandboxNucleoH533RE" cannot use the SPI driver without first specifying the peripheral instances to have handles for.
#endif
#if TARGET_NAME_IS_DemoI2C
    #error Target "DemoI2C" cannot use the SPI driver without first specifying the peripheral instances to have handles for.
#endif
#if TARGET_NAME_IS_DemoTimer
    #error Target "DemoTimer" cannot use the SPI driver without first specifying the peripheral instances to have handles for.
#endif
#if TARGET_NAME_IS_DemoSPI
    enum SPIHandle : u32
    {
        SPIHandle_primary,
    };
    static constexpr u32 SPIHandle_COUNT = 1;
    #define SPIx_ SPI_
    static const struct { typeof(SPI2) SPIx; typeof(NVICInterrupt_SPI2) NVICInterrupt_SPIx; typeof(STPY_SPI2_KERNEL_SOURCE) STPY_SPIx_KERNEL_SOURCE; typeof(STPY_SPI2_BYPASS_DIVIDER) STPY_SPIx_BYPASS_DIVIDER; typeof(STPY_SPI2_DIVIDER) STPY_SPIx_DIVIDER; typeof((struct CMSISTuple) { &RCC->APB1LRSTR, RCC_APB1LRSTR_SPI2RST_Pos, RCC_APB1LRSTR_SPI2RST_Msk }) SPIx_RESET; typeof((struct CMSISTuple) { &RCC->APB1LENR, RCC_APB1LENR_SPI2EN_Pos, RCC_APB1LENR_SPI2EN_Msk }) SPIx_ENABLE; typeof((struct CMSISTuple) { &RCC->CCIPR3, RCC_CCIPR3_SPI2SEL_Pos, RCC_CCIPR3_SPI2SEL_Msk }) SPIx_KERNEL_SOURCE; } SPI_TABLE[] =
        {
            [SPIHandle_primary] = { .SPIx = SPI2, .NVICInterrupt_SPIx = NVICInterrupt_SPI2, .STPY_SPIx_KERNEL_SOURCE = STPY_SPI2_KERNEL_SOURCE, .STPY_SPIx_BYPASS_DIVIDER = STPY_SPI2_BYPASS_DIVIDER, .STPY_SPIx_DIVIDER = STPY_SPI2_DIVIDER, .SPIx_RESET = (struct CMSISTuple) { &RCC->APB1LRSTR, RCC_APB1LRSTR_SPI2RST_Pos, RCC_APB1LRSTR_SPI2RST_Msk }, .SPIx_ENABLE = (struct CMSISTuple) { &RCC->APB1LENR, RCC_APB1LENR_SPI2EN_Pos, RCC_APB1LENR_SPI2EN_Msk }, .SPIx_KERNEL_SOURCE = (struct CMSISTuple) { &RCC->CCIPR3, RCC_CCIPR3_SPI2SEL_Pos, RCC_CCIPR3_SPI2SEL_Msk } },
        };
#endif
#undef _EXPAND_HANDLE
#define _EXPAND_HANDLE\
    \
    if (!(0 <= handle && handle < SPIHandle_COUNT))\
    {\
        panic;\
    }\
    \
    struct SPIDriver* const driver = &_SPI_drivers[handle];\
    \
    auto const SPIx = SPI_TABLE[handle].SPIx;\
    auto const NVICInterrupt_SPIx = SPI_TABLE[handle].NVICInterrupt_SPIx;\
    auto const STPY_SPIx_KERNEL_SOURCE = SPI_TABLE[handle].STPY_SPIx_KERNEL_SOURCE;\
    auto const STPY_SPIx_BYPASS_DIVIDER = SPI_TABLE[handle].STPY_SPIx_BYPASS_DIVIDER;\
    auto const STPY_SPIx_DIVIDER = SPI_TABLE[handle].STPY_SPIx_DIVIDER;\
    auto const SPIx_RESET = SPI_TABLE[handle].SPIx_RESET;\
    auto const SPIx_ENABLE = SPI_TABLE[handle].SPIx_ENABLE;\
    auto const SPIx_KERNEL_SOURCE = SPI_TABLE[handle].SPIx_KERNEL_SOURCE;\


#if TARGET_NAME_IS_SandboxNucleoH7S3L8
#endif
#if TARGET_NAME_IS_SandboxNucleoH533RE
#endif
#if TARGET_NAME_IS_DemoI2C
#endif
#if TARGET_NAME_IS_DemoTimer
#endif
#if TARGET_NAME_IS_DemoSPI

    static void
    _SPI_update_entirely(enum SPIHandle handle);

    INTERRUPT_SPI2
    {
        _SPI_update_entirely(SPIHandle_primary);
    }

#endif
