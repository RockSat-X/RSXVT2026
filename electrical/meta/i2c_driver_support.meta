#if TARGET_NAME_IS_SandboxNucleoH533RE
#endif
#if TARGET_NAME_IS_DemoI2C
    static I2CSlaveCallback INTERRUPT_I2Cx_bee;
    #define INTERRUPT_I2Cx_bee(...) static void INTERRUPT_I2Cx_bee(__VA_ARGS__)
#endif
#if TARGET_NAME_IS_DemoSPI
#endif
#if TARGET_NAME_IS_DemoBuzzer
#endif
#if TARGET_NAME_IS_DemoTimer
#endif
#if TARGET_NAME_IS_DemoTimekeeping
#endif
#if TARGET_NAME_IS_DemoSDMMC
#endif
#if TARGET_NAME_IS_MainFlightComputer
#endif
#if TARGET_NAME_IS_MainFlightComputer_NUCLEO
#endif
#if TARGET_NAME_IS_VehicleFlightComputer_R1
    static I2CSlaveCallback INTERRUPT_I2Cx_vehicle_interface;
    #define INTERRUPT_I2Cx_vehicle_interface(...) static void INTERRUPT_I2Cx_vehicle_interface(__VA_ARGS__)
#endif
#if TARGET_NAME_IS_VehicleFlightComputer_R2
#endif
#if TARGET_NAME_IS_DebugBoard
#endif
#if TARGET_NAME_IS_MainCameraSystem
#endif
#if TARGET_NAME_IS_DemoOVCAM
#endif
#if TARGET_NAME_IS_DemoAnalog
#endif
#if TARGET_NAME_IS_TestESP32s
#endif
#if TARGET_NAME_IS_SandboxNucleoH533RE
    #error Target 'SandboxNucleoH533RE' defines no handle for the 'I2C' driver.
#endif
#if TARGET_NAME_IS_DemoI2C
    enum I2CHandle : u32
    {
        I2CHandle_queen,
        I2CHandle_bee,
    };
    static constexpr u32 I2CHandle_COUNT = 2;
    #define I2Cx_ I2C_
    #define NVICInterrupt_I2Cx_EV_queen NVICInterrupt_I2C1_EV
    #define NVICInterrupt_I2Cx_ER_queen NVICInterrupt_I2C1_ER
    #define NVICInterrupt_I2Cx_EV_bee NVICInterrupt_I2C2_EV
    #define NVICInterrupt_I2Cx_ER_bee NVICInterrupt_I2C2_ER
    static const struct { typeof(I2CDriverMode_master) I2Cx_DRIVER_MODE; typeof(((u16) 0x000)) I2Cx_SLAVE_ADDRESS; typeof(I2C1) I2Cx; typeof(NVICInterrupt_I2C1_EV) NVICInterrupt_I2Cx_EV; typeof(NVICInterrupt_I2C1_ER) NVICInterrupt_I2Cx_ER; typeof(STPY_I2C1_KERNEL_SOURCE) STPY_I2Cx_KERNEL_SOURCE; typeof(STPY_I2C1_PRESC) STPY_I2Cx_PRESC; typeof(STPY_I2C1_SCLH) STPY_I2Cx_SCLH; typeof(STPY_I2C1_SCLL) STPY_I2Cx_SCLL; typeof(STPY_I2C1_TIMEOUTR_TIMEOUTA) STPY_I2Cx_TIMEOUTR_TIMEOUTA; typeof(2000000U) I2Cx_WATCHDOG_DURATION_US; typeof((struct CMSISTuple) { &RCC->APB1LRSTR, CONCAT(RCC_, APB1LRSTR_I2C1RST_Pos), CONCAT(RCC_, APB1LRSTR_I2C1RST_Msk) }) I2Cx_RESET; typeof((struct CMSISTuple) { &RCC->APB1LENR, CONCAT(RCC_, APB1LENR_I2C1EN_Pos), CONCAT(RCC_, APB1LENR_I2C1EN_Msk) }) I2Cx_ENABLE; typeof((struct CMSISTuple) { &RCC->CCIPR4, CONCAT(RCC_, CCIPR4_I2C1SEL_Pos), CONCAT(RCC_, CCIPR4_I2C1SEL_Msk) }) I2Cx_KERNEL_SOURCE; typeof((union I2CCallback) { nullptr }) I2Cx_CALLBACK; } I2C_TABLE[] =
        {
            [I2CHandle_queen] = { .I2Cx_DRIVER_MODE = I2CDriverMode_master, .I2Cx_SLAVE_ADDRESS = ((u16) 0x000), .I2Cx = I2C1, .NVICInterrupt_I2Cx_EV = NVICInterrupt_I2C1_EV, .NVICInterrupt_I2Cx_ER = NVICInterrupt_I2C1_ER, .STPY_I2Cx_KERNEL_SOURCE = STPY_I2C1_KERNEL_SOURCE, .STPY_I2Cx_PRESC = STPY_I2C1_PRESC, .STPY_I2Cx_SCLH = STPY_I2C1_SCLH, .STPY_I2Cx_SCLL = STPY_I2C1_SCLL, .STPY_I2Cx_TIMEOUTR_TIMEOUTA = STPY_I2C1_TIMEOUTR_TIMEOUTA, .I2Cx_WATCHDOG_DURATION_US = 2000000U, .I2Cx_RESET = (struct CMSISTuple) { &RCC->APB1LRSTR, CONCAT(RCC_, APB1LRSTR_I2C1RST_Pos), CONCAT(RCC_, APB1LRSTR_I2C1RST_Msk) }, .I2Cx_ENABLE = (struct CMSISTuple) { &RCC->APB1LENR, CONCAT(RCC_, APB1LENR_I2C1EN_Pos), CONCAT(RCC_, APB1LENR_I2C1EN_Msk) }, .I2Cx_KERNEL_SOURCE = (struct CMSISTuple) { &RCC->CCIPR4, CONCAT(RCC_, CCIPR4_I2C1SEL_Pos), CONCAT(RCC_, CCIPR4_I2C1SEL_Msk) }, .I2Cx_CALLBACK = (union I2CCallback) { nullptr }             },
            [I2CHandle_bee] =   { .I2Cx_DRIVER_MODE = I2CDriverMode_slave , .I2Cx_SLAVE_ADDRESS = ((u16) 0x01E), .I2Cx = I2C2, .NVICInterrupt_I2Cx_EV = NVICInterrupt_I2C2_EV, .NVICInterrupt_I2Cx_ER = NVICInterrupt_I2C2_ER, .STPY_I2Cx_KERNEL_SOURCE = STPY_I2C2_KERNEL_SOURCE, .STPY_I2Cx_PRESC = STPY_I2C2_PRESC, .STPY_I2Cx_SCLH = STPY_I2C2_SCLH, .STPY_I2Cx_SCLL = STPY_I2C2_SCLL, .STPY_I2Cx_TIMEOUTR_TIMEOUTA = STPY_I2C2_TIMEOUTR_TIMEOUTA, .I2Cx_WATCHDOG_DURATION_US = 2000000U, .I2Cx_RESET = (struct CMSISTuple) { &RCC->APB1LRSTR, CONCAT(RCC_, APB1LRSTR_I2C2RST_Pos), CONCAT(RCC_, APB1LRSTR_I2C2RST_Msk) }, .I2Cx_ENABLE = (struct CMSISTuple) { &RCC->APB1LENR, CONCAT(RCC_, APB1LENR_I2C2EN_Pos), CONCAT(RCC_, APB1LENR_I2C2EN_Msk) }, .I2Cx_KERNEL_SOURCE = (struct CMSISTuple) { &RCC->CCIPR4, CONCAT(RCC_, CCIPR4_I2C2SEL_Pos), CONCAT(RCC_, CCIPR4_I2C2SEL_Msk) }, .I2Cx_CALLBACK = (union I2CCallback) { &INTERRUPT_I2Cx_bee } },
        };
    static void
    _I2C_driver_interrupt(enum I2CHandle handle);
    INTERRUPT_I2C1_EV(void)
    {
        _I2C_driver_interrupt(I2CHandle_queen);
    }
    INTERRUPT_I2C1_ER(void)
    {
        _I2C_driver_interrupt(I2CHandle_queen);
    }
    INTERRUPT_I2C2_EV(void)
    {
        _I2C_driver_interrupt(I2CHandle_bee);
    }
    INTERRUPT_I2C2_ER(void)
    {
        _I2C_driver_interrupt(I2CHandle_bee);
    }
#endif
#if TARGET_NAME_IS_DemoSPI
    #error Target 'DemoSPI' defines no handle for the 'I2C' driver.
#endif
#if TARGET_NAME_IS_DemoBuzzer
    #error Target 'DemoBuzzer' defines no handle for the 'I2C' driver.
#endif
#if TARGET_NAME_IS_DemoTimer
    #error Target 'DemoTimer' defines no handle for the 'I2C' driver.
#endif
#if TARGET_NAME_IS_DemoTimekeeping
    #error Target 'DemoTimekeeping' defines no handle for the 'I2C' driver.
#endif
#if TARGET_NAME_IS_DemoSDMMC
    #error Target 'DemoSDMMC' defines no handle for the 'I2C' driver.
#endif
#if TARGET_NAME_IS_MainFlightComputer
    #error Target 'MainFlightComputer' defines no handle for the 'I2C' driver.
#endif
#if TARGET_NAME_IS_MainFlightComputer_NUCLEO
    enum I2CHandle : u32
    {
        I2CHandle_vehicle_interface,
    };
    static constexpr u32 I2CHandle_COUNT = 1;
    #define I2Cx_ I2C_
    #define NVICInterrupt_I2Cx_EV_vehicle_interface NVICInterrupt_I2C1_EV
    #define NVICInterrupt_I2Cx_ER_vehicle_interface NVICInterrupt_I2C1_ER
    static const struct { typeof(I2CDriverMode_master) I2Cx_DRIVER_MODE; typeof(((u16) 0x000)) I2Cx_SLAVE_ADDRESS; typeof(I2C1) I2Cx; typeof(NVICInterrupt_I2C1_EV) NVICInterrupt_I2Cx_EV; typeof(NVICInterrupt_I2C1_ER) NVICInterrupt_I2Cx_ER; typeof(STPY_I2C1_KERNEL_SOURCE) STPY_I2Cx_KERNEL_SOURCE; typeof(STPY_I2C1_PRESC) STPY_I2Cx_PRESC; typeof(STPY_I2C1_SCLH) STPY_I2Cx_SCLH; typeof(STPY_I2C1_SCLL) STPY_I2Cx_SCLL; typeof(STPY_I2C1_TIMEOUTR_TIMEOUTA) STPY_I2Cx_TIMEOUTR_TIMEOUTA; typeof(2000000U) I2Cx_WATCHDOG_DURATION_US; typeof((struct CMSISTuple) { &RCC->APB1LRSTR, CONCAT(RCC_, APB1LRSTR_I2C1RST_Pos), CONCAT(RCC_, APB1LRSTR_I2C1RST_Msk) }) I2Cx_RESET; typeof((struct CMSISTuple) { &RCC->APB1LENR, CONCAT(RCC_, APB1LENR_I2C1EN_Pos), CONCAT(RCC_, APB1LENR_I2C1EN_Msk) }) I2Cx_ENABLE; typeof((struct CMSISTuple) { &RCC->CCIPR4, CONCAT(RCC_, CCIPR4_I2C1SEL_Pos), CONCAT(RCC_, CCIPR4_I2C1SEL_Msk) }) I2Cx_KERNEL_SOURCE; typeof((union I2CCallback) { nullptr }) I2Cx_CALLBACK; } I2C_TABLE[] =
        {
            [I2CHandle_vehicle_interface] = { .I2Cx_DRIVER_MODE = I2CDriverMode_master, .I2Cx_SLAVE_ADDRESS = ((u16) 0x000), .I2Cx = I2C1, .NVICInterrupt_I2Cx_EV = NVICInterrupt_I2C1_EV, .NVICInterrupt_I2Cx_ER = NVICInterrupt_I2C1_ER, .STPY_I2Cx_KERNEL_SOURCE = STPY_I2C1_KERNEL_SOURCE, .STPY_I2Cx_PRESC = STPY_I2C1_PRESC, .STPY_I2Cx_SCLH = STPY_I2C1_SCLH, .STPY_I2Cx_SCLL = STPY_I2C1_SCLL, .STPY_I2Cx_TIMEOUTR_TIMEOUTA = STPY_I2C1_TIMEOUTR_TIMEOUTA, .I2Cx_WATCHDOG_DURATION_US = 2000000U, .I2Cx_RESET = (struct CMSISTuple) { &RCC->APB1LRSTR, CONCAT(RCC_, APB1LRSTR_I2C1RST_Pos), CONCAT(RCC_, APB1LRSTR_I2C1RST_Msk) }, .I2Cx_ENABLE = (struct CMSISTuple) { &RCC->APB1LENR, CONCAT(RCC_, APB1LENR_I2C1EN_Pos), CONCAT(RCC_, APB1LENR_I2C1EN_Msk) }, .I2Cx_KERNEL_SOURCE = (struct CMSISTuple) { &RCC->CCIPR4, CONCAT(RCC_, CCIPR4_I2C1SEL_Pos), CONCAT(RCC_, CCIPR4_I2C1SEL_Msk) }, .I2Cx_CALLBACK = (union I2CCallback) { nullptr } },
        };
    static void
    _I2C_driver_interrupt(enum I2CHandle handle);
    INTERRUPT_I2C1_EV(void)
    {
        _I2C_driver_interrupt(I2CHandle_vehicle_interface);
    }
    INTERRUPT_I2C1_ER(void)
    {
        _I2C_driver_interrupt(I2CHandle_vehicle_interface);
    }
#endif
#if TARGET_NAME_IS_VehicleFlightComputer_R1
    enum I2CHandle : u32
    {
        I2CHandle_vehicle_interface,
    };
    static constexpr u32 I2CHandle_COUNT = 1;
    #define I2Cx_ I2C_
    #define NVICInterrupt_I2Cx_EV_vehicle_interface NVICInterrupt_I2C3_EV
    #define NVICInterrupt_I2Cx_ER_vehicle_interface NVICInterrupt_I2C3_ER
    static const struct { typeof(I2CDriverMode_slave) I2Cx_DRIVER_MODE; typeof(((u16) 0x012)) I2Cx_SLAVE_ADDRESS; typeof(I2C3) I2Cx; typeof(NVICInterrupt_I2C3_EV) NVICInterrupt_I2Cx_EV; typeof(NVICInterrupt_I2C3_ER) NVICInterrupt_I2Cx_ER; typeof(STPY_I2C3_KERNEL_SOURCE) STPY_I2Cx_KERNEL_SOURCE; typeof(STPY_I2C3_PRESC) STPY_I2Cx_PRESC; typeof(STPY_I2C3_SCLH) STPY_I2Cx_SCLH; typeof(STPY_I2C3_SCLL) STPY_I2Cx_SCLL; typeof(STPY_I2C3_TIMEOUTR_TIMEOUTA) STPY_I2Cx_TIMEOUTR_TIMEOUTA; typeof(2000000U) I2Cx_WATCHDOG_DURATION_US; typeof((struct CMSISTuple) { &RCC->APB3RSTR, CONCAT(RCC_, APB3RSTR_I2C3RST_Pos), CONCAT(RCC_, APB3RSTR_I2C3RST_Msk) }) I2Cx_RESET; typeof((struct CMSISTuple) { &RCC->APB3ENR, CONCAT(RCC_, APB3ENR_I2C3EN_Pos), CONCAT(RCC_, APB3ENR_I2C3EN_Msk) }) I2Cx_ENABLE; typeof((struct CMSISTuple) { &RCC->CCIPR4, CONCAT(RCC_, CCIPR4_I2C3SEL_Pos), CONCAT(RCC_, CCIPR4_I2C3SEL_Msk) }) I2Cx_KERNEL_SOURCE; typeof((union I2CCallback) { &INTERRUPT_I2Cx_vehicle_interface }) I2Cx_CALLBACK; } I2C_TABLE[] =
        {
            [I2CHandle_vehicle_interface] = { .I2Cx_DRIVER_MODE = I2CDriverMode_slave, .I2Cx_SLAVE_ADDRESS = ((u16) 0x012), .I2Cx = I2C3, .NVICInterrupt_I2Cx_EV = NVICInterrupt_I2C3_EV, .NVICInterrupt_I2Cx_ER = NVICInterrupt_I2C3_ER, .STPY_I2Cx_KERNEL_SOURCE = STPY_I2C3_KERNEL_SOURCE, .STPY_I2Cx_PRESC = STPY_I2C3_PRESC, .STPY_I2Cx_SCLH = STPY_I2C3_SCLH, .STPY_I2Cx_SCLL = STPY_I2C3_SCLL, .STPY_I2Cx_TIMEOUTR_TIMEOUTA = STPY_I2C3_TIMEOUTR_TIMEOUTA, .I2Cx_WATCHDOG_DURATION_US = 2000000U, .I2Cx_RESET = (struct CMSISTuple) { &RCC->APB3RSTR, CONCAT(RCC_, APB3RSTR_I2C3RST_Pos), CONCAT(RCC_, APB3RSTR_I2C3RST_Msk) }, .I2Cx_ENABLE = (struct CMSISTuple) { &RCC->APB3ENR, CONCAT(RCC_, APB3ENR_I2C3EN_Pos), CONCAT(RCC_, APB3ENR_I2C3EN_Msk) }, .I2Cx_KERNEL_SOURCE = (struct CMSISTuple) { &RCC->CCIPR4, CONCAT(RCC_, CCIPR4_I2C3SEL_Pos), CONCAT(RCC_, CCIPR4_I2C3SEL_Msk) }, .I2Cx_CALLBACK = (union I2CCallback) { &INTERRUPT_I2Cx_vehicle_interface } },
        };
    static void
    _I2C_driver_interrupt(enum I2CHandle handle);
    INTERRUPT_I2C3_EV(void)
    {
        _I2C_driver_interrupt(I2CHandle_vehicle_interface);
    }
    INTERRUPT_I2C3_ER(void)
    {
        _I2C_driver_interrupt(I2CHandle_vehicle_interface);
    }
#endif
#if TARGET_NAME_IS_VehicleFlightComputer_R2
    #error Target 'VehicleFlightComputer_R2' defines no handle for the 'I2C' driver.
#endif
#if TARGET_NAME_IS_DebugBoard
    #error Target 'DebugBoard' defines no handle for the 'I2C' driver.
#endif
#if TARGET_NAME_IS_MainCameraSystem
    enum I2CHandle : u32
    {
        I2CHandle_ovcam_sccb,
    };
    static constexpr u32 I2CHandle_COUNT = 1;
    #define I2Cx_ I2C_
    #define NVICInterrupt_I2Cx_EV_ovcam_sccb NVICInterrupt_I2C2_EV
    #define NVICInterrupt_I2Cx_ER_ovcam_sccb NVICInterrupt_I2C2_ER
    static const struct { typeof(I2CDriverMode_master) I2Cx_DRIVER_MODE; typeof(((u16) 0x000)) I2Cx_SLAVE_ADDRESS; typeof(I2C2) I2Cx; typeof(NVICInterrupt_I2C2_EV) NVICInterrupt_I2Cx_EV; typeof(NVICInterrupt_I2C2_ER) NVICInterrupt_I2Cx_ER; typeof(STPY_I2C2_KERNEL_SOURCE) STPY_I2Cx_KERNEL_SOURCE; typeof(STPY_I2C2_PRESC) STPY_I2Cx_PRESC; typeof(STPY_I2C2_SCLH) STPY_I2Cx_SCLH; typeof(STPY_I2C2_SCLL) STPY_I2Cx_SCLL; typeof(STPY_I2C2_TIMEOUTR_TIMEOUTA) STPY_I2Cx_TIMEOUTR_TIMEOUTA; typeof(2000000U) I2Cx_WATCHDOG_DURATION_US; typeof((struct CMSISTuple) { &RCC->APB1LRSTR, CONCAT(RCC_, APB1LRSTR_I2C2RST_Pos), CONCAT(RCC_, APB1LRSTR_I2C2RST_Msk) }) I2Cx_RESET; typeof((struct CMSISTuple) { &RCC->APB1LENR, CONCAT(RCC_, APB1LENR_I2C2EN_Pos), CONCAT(RCC_, APB1LENR_I2C2EN_Msk) }) I2Cx_ENABLE; typeof((struct CMSISTuple) { &RCC->CCIPR4, CONCAT(RCC_, CCIPR4_I2C2SEL_Pos), CONCAT(RCC_, CCIPR4_I2C2SEL_Msk) }) I2Cx_KERNEL_SOURCE; typeof((union I2CCallback) { nullptr }) I2Cx_CALLBACK; } I2C_TABLE[] =
        {
            [I2CHandle_ovcam_sccb] = { .I2Cx_DRIVER_MODE = I2CDriverMode_master, .I2Cx_SLAVE_ADDRESS = ((u16) 0x000), .I2Cx = I2C2, .NVICInterrupt_I2Cx_EV = NVICInterrupt_I2C2_EV, .NVICInterrupt_I2Cx_ER = NVICInterrupt_I2C2_ER, .STPY_I2Cx_KERNEL_SOURCE = STPY_I2C2_KERNEL_SOURCE, .STPY_I2Cx_PRESC = STPY_I2C2_PRESC, .STPY_I2Cx_SCLH = STPY_I2C2_SCLH, .STPY_I2Cx_SCLL = STPY_I2C2_SCLL, .STPY_I2Cx_TIMEOUTR_TIMEOUTA = STPY_I2C2_TIMEOUTR_TIMEOUTA, .I2Cx_WATCHDOG_DURATION_US = 2000000U, .I2Cx_RESET = (struct CMSISTuple) { &RCC->APB1LRSTR, CONCAT(RCC_, APB1LRSTR_I2C2RST_Pos), CONCAT(RCC_, APB1LRSTR_I2C2RST_Msk) }, .I2Cx_ENABLE = (struct CMSISTuple) { &RCC->APB1LENR, CONCAT(RCC_, APB1LENR_I2C2EN_Pos), CONCAT(RCC_, APB1LENR_I2C2EN_Msk) }, .I2Cx_KERNEL_SOURCE = (struct CMSISTuple) { &RCC->CCIPR4, CONCAT(RCC_, CCIPR4_I2C2SEL_Pos), CONCAT(RCC_, CCIPR4_I2C2SEL_Msk) }, .I2Cx_CALLBACK = (union I2CCallback) { nullptr } },
        };
    static void
    _I2C_driver_interrupt(enum I2CHandle handle);
    INTERRUPT_I2C2_EV(void)
    {
        _I2C_driver_interrupt(I2CHandle_ovcam_sccb);
    }
    INTERRUPT_I2C2_ER(void)
    {
        _I2C_driver_interrupt(I2CHandle_ovcam_sccb);
    }
#endif
#if TARGET_NAME_IS_DemoOVCAM
    enum I2CHandle : u32
    {
        I2CHandle_ovcam_sccb,
    };
    static constexpr u32 I2CHandle_COUNT = 1;
    #define I2Cx_ I2C_
    #define NVICInterrupt_I2Cx_EV_ovcam_sccb NVICInterrupt_I2C2_EV
    #define NVICInterrupt_I2Cx_ER_ovcam_sccb NVICInterrupt_I2C2_ER
    static const struct { typeof(I2CDriverMode_master) I2Cx_DRIVER_MODE; typeof(((u16) 0x000)) I2Cx_SLAVE_ADDRESS; typeof(I2C2) I2Cx; typeof(NVICInterrupt_I2C2_EV) NVICInterrupt_I2Cx_EV; typeof(NVICInterrupt_I2C2_ER) NVICInterrupt_I2Cx_ER; typeof(STPY_I2C2_KERNEL_SOURCE) STPY_I2Cx_KERNEL_SOURCE; typeof(STPY_I2C2_PRESC) STPY_I2Cx_PRESC; typeof(STPY_I2C2_SCLH) STPY_I2Cx_SCLH; typeof(STPY_I2C2_SCLL) STPY_I2Cx_SCLL; typeof(STPY_I2C2_TIMEOUTR_TIMEOUTA) STPY_I2Cx_TIMEOUTR_TIMEOUTA; typeof(2000000U) I2Cx_WATCHDOG_DURATION_US; typeof((struct CMSISTuple) { &RCC->APB1LRSTR, CONCAT(RCC_, APB1LRSTR_I2C2RST_Pos), CONCAT(RCC_, APB1LRSTR_I2C2RST_Msk) }) I2Cx_RESET; typeof((struct CMSISTuple) { &RCC->APB1LENR, CONCAT(RCC_, APB1LENR_I2C2EN_Pos), CONCAT(RCC_, APB1LENR_I2C2EN_Msk) }) I2Cx_ENABLE; typeof((struct CMSISTuple) { &RCC->CCIPR4, CONCAT(RCC_, CCIPR4_I2C2SEL_Pos), CONCAT(RCC_, CCIPR4_I2C2SEL_Msk) }) I2Cx_KERNEL_SOURCE; typeof((union I2CCallback) { nullptr }) I2Cx_CALLBACK; } I2C_TABLE[] =
        {
            [I2CHandle_ovcam_sccb] = { .I2Cx_DRIVER_MODE = I2CDriverMode_master, .I2Cx_SLAVE_ADDRESS = ((u16) 0x000), .I2Cx = I2C2, .NVICInterrupt_I2Cx_EV = NVICInterrupt_I2C2_EV, .NVICInterrupt_I2Cx_ER = NVICInterrupt_I2C2_ER, .STPY_I2Cx_KERNEL_SOURCE = STPY_I2C2_KERNEL_SOURCE, .STPY_I2Cx_PRESC = STPY_I2C2_PRESC, .STPY_I2Cx_SCLH = STPY_I2C2_SCLH, .STPY_I2Cx_SCLL = STPY_I2C2_SCLL, .STPY_I2Cx_TIMEOUTR_TIMEOUTA = STPY_I2C2_TIMEOUTR_TIMEOUTA, .I2Cx_WATCHDOG_DURATION_US = 2000000U, .I2Cx_RESET = (struct CMSISTuple) { &RCC->APB1LRSTR, CONCAT(RCC_, APB1LRSTR_I2C2RST_Pos), CONCAT(RCC_, APB1LRSTR_I2C2RST_Msk) }, .I2Cx_ENABLE = (struct CMSISTuple) { &RCC->APB1LENR, CONCAT(RCC_, APB1LENR_I2C2EN_Pos), CONCAT(RCC_, APB1LENR_I2C2EN_Msk) }, .I2Cx_KERNEL_SOURCE = (struct CMSISTuple) { &RCC->CCIPR4, CONCAT(RCC_, CCIPR4_I2C2SEL_Pos), CONCAT(RCC_, CCIPR4_I2C2SEL_Msk) }, .I2Cx_CALLBACK = (union I2CCallback) { nullptr } },
        };
    static void
    _I2C_driver_interrupt(enum I2CHandle handle);
    INTERRUPT_I2C2_EV(void)
    {
        _I2C_driver_interrupt(I2CHandle_ovcam_sccb);
    }
    INTERRUPT_I2C2_ER(void)
    {
        _I2C_driver_interrupt(I2CHandle_ovcam_sccb);
    }
#endif
#if TARGET_NAME_IS_DemoAnalog
    #error Target 'DemoAnalog' defines no handle for the 'I2C' driver.
#endif
#if TARGET_NAME_IS_TestESP32s
    #error Target 'TestESP32s' defines no handle for the 'I2C' driver.
#endif
#undef _EXPAND_HANDLE
#define _EXPAND_HANDLE\
    if (!(0 <= handle && handle < I2CHandle_COUNT))\
        sorry\
    auto const driver = &_I2C_drivers[handle];\
    auto const I2Cx_DRIVER_MODE = I2C_TABLE[handle].I2Cx_DRIVER_MODE;\
    auto const I2Cx_SLAVE_ADDRESS = I2C_TABLE[handle].I2Cx_SLAVE_ADDRESS;\
    auto const I2Cx = I2C_TABLE[handle].I2Cx;\
    auto const NVICInterrupt_I2Cx_EV = I2C_TABLE[handle].NVICInterrupt_I2Cx_EV;\
    auto const NVICInterrupt_I2Cx_ER = I2C_TABLE[handle].NVICInterrupt_I2Cx_ER;\
    auto const STPY_I2Cx_KERNEL_SOURCE = I2C_TABLE[handle].STPY_I2Cx_KERNEL_SOURCE;\
    auto const STPY_I2Cx_PRESC = I2C_TABLE[handle].STPY_I2Cx_PRESC;\
    auto const STPY_I2Cx_SCLH = I2C_TABLE[handle].STPY_I2Cx_SCLH;\
    auto const STPY_I2Cx_SCLL = I2C_TABLE[handle].STPY_I2Cx_SCLL;\
    auto const STPY_I2Cx_TIMEOUTR_TIMEOUTA = I2C_TABLE[handle].STPY_I2Cx_TIMEOUTR_TIMEOUTA;\
    auto const I2Cx_WATCHDOG_DURATION_US = I2C_TABLE[handle].I2Cx_WATCHDOG_DURATION_US;\
    auto const I2Cx_RESET = I2C_TABLE[handle].I2Cx_RESET;\
    auto const I2Cx_ENABLE = I2C_TABLE[handle].I2Cx_ENABLE;\
    auto const I2Cx_KERNEL_SOURCE = I2C_TABLE[handle].I2Cx_KERNEL_SOURCE;\
    auto const I2Cx_CALLBACK = I2C_TABLE[handle].I2Cx_CALLBACK;\

#if TARGET_NAME_IS_SandboxNucleoH533RE
#endif
#if TARGET_NAME_IS_DemoI2C
#endif
#if TARGET_NAME_IS_DemoSPI
#endif
#if TARGET_NAME_IS_DemoBuzzer
#endif
#if TARGET_NAME_IS_DemoTimer
#endif
#if TARGET_NAME_IS_DemoTimekeeping
#endif
#if TARGET_NAME_IS_DemoSDMMC
#endif
#if TARGET_NAME_IS_MainFlightComputer
#endif
#if TARGET_NAME_IS_MainFlightComputer_NUCLEO
#endif
#if TARGET_NAME_IS_VehicleFlightComputer_R1
#endif
#if TARGET_NAME_IS_VehicleFlightComputer_R2
#endif
#if TARGET_NAME_IS_DebugBoard
#endif
#if TARGET_NAME_IS_MainCameraSystem
#endif
#if TARGET_NAME_IS_DemoOVCAM
#endif
#if TARGET_NAME_IS_DemoAnalog
#endif
#if TARGET_NAME_IS_TestESP32s
#endif
