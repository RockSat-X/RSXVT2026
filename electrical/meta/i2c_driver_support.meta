#if TARGET_NAME_IS_SandboxNucleoH7S3L8
    #error Target 'SandboxNucleoH7S3L8' defines no handle for the 'I2C' driver.
#endif
#if TARGET_NAME_IS_SandboxNucleoH533RE
    #error Target 'SandboxNucleoH533RE' defines no handle for the 'I2C' driver.
#endif
#if TARGET_NAME_IS_DemoI2C
    enum I2CHandle : u32
    {
        I2CHandle_queen,
        I2CHandle_bee,
    };
    static constexpr u32 I2CHandle_COUNT = 2;
    #define I2Cx_ I2C_
    static const struct { typeof(I2CDriverRole_master) I2Cx_DRIVER_ROLE; typeof(((u16) 0x000)) I2Cx_SLAVE_ADDRESS; typeof(I2C1) I2Cx; typeof(NVICInterrupt_I2C1_EV) NVICInterrupt_I2Cx_EV; typeof(NVICInterrupt_I2C1_ER) NVICInterrupt_I2Cx_ER; typeof(STPY_I2C1_KERNEL_SOURCE) STPY_I2Cx_KERNEL_SOURCE; typeof(STPY_I2C1_PRESC) STPY_I2Cx_PRESC; typeof(STPY_I2C1_SCLH) STPY_I2Cx_SCLH; typeof(STPY_I2C1_SCLL) STPY_I2Cx_SCLL; typeof((struct CMSISTuple) { &RCC->APB1LRSTR, CONCAT(RCC_, APB1LRSTR_I2C1RST_Pos), CONCAT(RCC_, APB1LRSTR_I2C1RST_Msk) }) I2Cx_RESET; typeof((struct CMSISTuple) { &RCC->APB1LENR, CONCAT(RCC_, APB1LENR_I2C1EN_Pos), CONCAT(RCC_, APB1LENR_I2C1EN_Msk) }) I2Cx_ENABLE; typeof((struct CMSISTuple) { &RCC->CCIPR4, CONCAT(RCC_, CCIPR4_I2C1SEL_Pos), CONCAT(RCC_, CCIPR4_I2C1SEL_Msk) }) I2Cx_KERNEL_SOURCE; } I2C_TABLE[] =
        {
            [I2CHandle_queen] = { .I2Cx_DRIVER_ROLE = I2CDriverRole_master, .I2Cx_SLAVE_ADDRESS = ((u16) 0x000), .I2Cx = I2C1, .NVICInterrupt_I2Cx_EV = NVICInterrupt_I2C1_EV, .NVICInterrupt_I2Cx_ER = NVICInterrupt_I2C1_ER, .STPY_I2Cx_KERNEL_SOURCE = STPY_I2C1_KERNEL_SOURCE, .STPY_I2Cx_PRESC = STPY_I2C1_PRESC, .STPY_I2Cx_SCLH = STPY_I2C1_SCLH, .STPY_I2Cx_SCLL = STPY_I2C1_SCLL, .I2Cx_RESET = (struct CMSISTuple) { &RCC->APB1LRSTR, CONCAT(RCC_, APB1LRSTR_I2C1RST_Pos), CONCAT(RCC_, APB1LRSTR_I2C1RST_Msk) }, .I2Cx_ENABLE = (struct CMSISTuple) { &RCC->APB1LENR, CONCAT(RCC_, APB1LENR_I2C1EN_Pos), CONCAT(RCC_, APB1LENR_I2C1EN_Msk) }, .I2Cx_KERNEL_SOURCE = (struct CMSISTuple) { &RCC->CCIPR4, CONCAT(RCC_, CCIPR4_I2C1SEL_Pos), CONCAT(RCC_, CCIPR4_I2C1SEL_Msk) } },
            [I2CHandle_bee] =   { .I2Cx_DRIVER_ROLE = I2CDriverRole_slave , .I2Cx_SLAVE_ADDRESS = ((u16) 0x01E), .I2Cx = I2C2, .NVICInterrupt_I2Cx_EV = NVICInterrupt_I2C2_EV, .NVICInterrupt_I2Cx_ER = NVICInterrupt_I2C2_ER, .STPY_I2Cx_KERNEL_SOURCE = STPY_I2C2_KERNEL_SOURCE, .STPY_I2Cx_PRESC = STPY_I2C2_PRESC, .STPY_I2Cx_SCLH = STPY_I2C2_SCLH, .STPY_I2Cx_SCLL = STPY_I2C2_SCLL, .I2Cx_RESET = (struct CMSISTuple) { &RCC->APB1LRSTR, CONCAT(RCC_, APB1LRSTR_I2C2RST_Pos), CONCAT(RCC_, APB1LRSTR_I2C2RST_Msk) }, .I2Cx_ENABLE = (struct CMSISTuple) { &RCC->APB1LENR, CONCAT(RCC_, APB1LENR_I2C2EN_Pos), CONCAT(RCC_, APB1LENR_I2C2EN_Msk) }, .I2Cx_KERNEL_SOURCE = (struct CMSISTuple) { &RCC->CCIPR4, CONCAT(RCC_, CCIPR4_I2C2SEL_Pos), CONCAT(RCC_, CCIPR4_I2C2SEL_Msk) } },
        };
    static void
    _I2C_driver_interrupt(enum I2CHandle handle);
    INTERRUPT_I2C1_EV
    {
        _I2C_driver_interrupt(I2CHandle_queen);
    }
    INTERRUPT_I2C1_ER
    {
        _I2C_driver_interrupt(I2CHandle_queen);
    }
    INTERRUPT_I2C2_EV
    {
        _I2C_driver_interrupt(I2CHandle_bee);
    }
    INTERRUPT_I2C2_ER
    {
        _I2C_driver_interrupt(I2CHandle_bee);
    }
#endif
#if TARGET_NAME_IS_DemoTimer
    #error Target 'DemoTimer' defines no handle for the 'I2C' driver.
#endif
#if TARGET_NAME_IS_DemoSPI
    #error Target 'DemoSPI' defines no handle for the 'I2C' driver.
#endif
#if TARGET_NAME_IS_DemoTimekeeping
    #error Target 'DemoTimekeeping' defines no handle for the 'I2C' driver.
#endif
#if TARGET_NAME_IS_DemoSDMMC
    #error Target 'DemoSDMMC' defines no handle for the 'I2C' driver.
#endif
#if TARGET_NAME_IS_SensorShield
    enum I2CHandle : u32
    {
        I2CHandle_primary,
    };
    static constexpr u32 I2CHandle_COUNT = 1;
    #define I2Cx_ I2C_
    static const struct { typeof(I2CDriverRole_master) I2Cx_DRIVER_ROLE; typeof(((u16) 0x000)) I2Cx_SLAVE_ADDRESS; typeof(I2C1) I2Cx; typeof(NVICInterrupt_I2C1_EV) NVICInterrupt_I2Cx_EV; typeof(NVICInterrupt_I2C1_ER) NVICInterrupt_I2Cx_ER; typeof(STPY_I2C1_KERNEL_SOURCE) STPY_I2Cx_KERNEL_SOURCE; typeof(STPY_I2C1_PRESC) STPY_I2Cx_PRESC; typeof(STPY_I2C1_SCLH) STPY_I2Cx_SCLH; typeof(STPY_I2C1_SCLL) STPY_I2Cx_SCLL; typeof((struct CMSISTuple) { &RCC->APB1LRSTR, CONCAT(RCC_, APB1LRSTR_I2C1RST_Pos), CONCAT(RCC_, APB1LRSTR_I2C1RST_Msk) }) I2Cx_RESET; typeof((struct CMSISTuple) { &RCC->APB1LENR, CONCAT(RCC_, APB1LENR_I2C1EN_Pos), CONCAT(RCC_, APB1LENR_I2C1EN_Msk) }) I2Cx_ENABLE; typeof((struct CMSISTuple) { &RCC->CCIPR4, CONCAT(RCC_, CCIPR4_I2C1SEL_Pos), CONCAT(RCC_, CCIPR4_I2C1SEL_Msk) }) I2Cx_KERNEL_SOURCE; } I2C_TABLE[] =
        {
            [I2CHandle_primary] = { .I2Cx_DRIVER_ROLE = I2CDriverRole_master, .I2Cx_SLAVE_ADDRESS = ((u16) 0x000), .I2Cx = I2C1, .NVICInterrupt_I2Cx_EV = NVICInterrupt_I2C1_EV, .NVICInterrupt_I2Cx_ER = NVICInterrupt_I2C1_ER, .STPY_I2Cx_KERNEL_SOURCE = STPY_I2C1_KERNEL_SOURCE, .STPY_I2Cx_PRESC = STPY_I2C1_PRESC, .STPY_I2Cx_SCLH = STPY_I2C1_SCLH, .STPY_I2Cx_SCLL = STPY_I2C1_SCLL, .I2Cx_RESET = (struct CMSISTuple) { &RCC->APB1LRSTR, CONCAT(RCC_, APB1LRSTR_I2C1RST_Pos), CONCAT(RCC_, APB1LRSTR_I2C1RST_Msk) }, .I2Cx_ENABLE = (struct CMSISTuple) { &RCC->APB1LENR, CONCAT(RCC_, APB1LENR_I2C1EN_Pos), CONCAT(RCC_, APB1LENR_I2C1EN_Msk) }, .I2Cx_KERNEL_SOURCE = (struct CMSISTuple) { &RCC->CCIPR4, CONCAT(RCC_, CCIPR4_I2C1SEL_Pos), CONCAT(RCC_, CCIPR4_I2C1SEL_Msk) } },
        };
    static void
    _I2C_driver_interrupt(enum I2CHandle handle);
    INTERRUPT_I2C1_EV
    {
        _I2C_driver_interrupt(I2CHandle_primary);
    }
    INTERRUPT_I2C1_ER
    {
        _I2C_driver_interrupt(I2CHandle_primary);
    }
#endif
#if TARGET_NAME_IS_MainFlightComputer
    #error Target 'MainFlightComputer' defines no handle for the 'I2C' driver.
#endif
#if TARGET_NAME_IS_VehicleFlightComputer
    #error Target 'VehicleFlightComputer' defines no handle for the 'I2C' driver.
#endif
#if TARGET_NAME_IS_DemoStepper
    #error Target 'DemoStepper' defines no handle for the 'I2C' driver.
#endif
#undef _EXPAND_HANDLE
#define _EXPAND_HANDLE\
    if (!(0 <= handle && handle < I2CHandle_COUNT))\
        panic;\
    auto const driver = &_I2C_drivers[handle];\
    auto const I2Cx_DRIVER_ROLE = I2C_TABLE[handle].I2Cx_DRIVER_ROLE;\
    auto const I2Cx_SLAVE_ADDRESS = I2C_TABLE[handle].I2Cx_SLAVE_ADDRESS;\
    auto const I2Cx = I2C_TABLE[handle].I2Cx;\
    auto const NVICInterrupt_I2Cx_EV = I2C_TABLE[handle].NVICInterrupt_I2Cx_EV;\
    auto const NVICInterrupt_I2Cx_ER = I2C_TABLE[handle].NVICInterrupt_I2Cx_ER;\
    auto const STPY_I2Cx_KERNEL_SOURCE = I2C_TABLE[handle].STPY_I2Cx_KERNEL_SOURCE;\
    auto const STPY_I2Cx_PRESC = I2C_TABLE[handle].STPY_I2Cx_PRESC;\
    auto const STPY_I2Cx_SCLH = I2C_TABLE[handle].STPY_I2Cx_SCLH;\
    auto const STPY_I2Cx_SCLL = I2C_TABLE[handle].STPY_I2Cx_SCLL;\
    auto const I2Cx_RESET = I2C_TABLE[handle].I2Cx_RESET;\
    auto const I2Cx_ENABLE = I2C_TABLE[handle].I2Cx_ENABLE;\
    auto const I2Cx_KERNEL_SOURCE = I2C_TABLE[handle].I2Cx_KERNEL_SOURCE;\

#if TARGET_NAME_IS_SandboxNucleoH7S3L8
    static void
    INTERRUPT_i2c_slave_callback(enum I2CHandle handle, enum I2CSlaveEvent event, u8* data)
    {
        panic;
    }
#endif
#if TARGET_NAME_IS_SandboxNucleoH533RE
    static void
    INTERRUPT_i2c_slave_callback(enum I2CHandle handle, enum I2CSlaveEvent event, u8* data)
    {
        panic;
    }
#endif
#if TARGET_NAME_IS_DemoI2C
    static void
    INTERRUPT_i2c_slave_callback(enum I2CHandle handle, enum I2CSlaveEvent event, u8* data);
#endif
#if TARGET_NAME_IS_DemoTimer
    static void
    INTERRUPT_i2c_slave_callback(enum I2CHandle handle, enum I2CSlaveEvent event, u8* data)
    {
        panic;
    }
#endif
#if TARGET_NAME_IS_DemoSPI
    static void
    INTERRUPT_i2c_slave_callback(enum I2CHandle handle, enum I2CSlaveEvent event, u8* data)
    {
        panic;
    }
#endif
#if TARGET_NAME_IS_DemoTimekeeping
    static void
    INTERRUPT_i2c_slave_callback(enum I2CHandle handle, enum I2CSlaveEvent event, u8* data)
    {
        panic;
    }
#endif
#if TARGET_NAME_IS_DemoSDMMC
    static void
    INTERRUPT_i2c_slave_callback(enum I2CHandle handle, enum I2CSlaveEvent event, u8* data)
    {
        panic;
    }
#endif
#if TARGET_NAME_IS_SensorShield
    static void
    INTERRUPT_i2c_slave_callback(enum I2CHandle handle, enum I2CSlaveEvent event, u8* data)
    {
        panic;
    }
#endif
#if TARGET_NAME_IS_MainFlightComputer
    static void
    INTERRUPT_i2c_slave_callback(enum I2CHandle handle, enum I2CSlaveEvent event, u8* data)
    {
        panic;
    }
#endif
#if TARGET_NAME_IS_VehicleFlightComputer
    static void
    INTERRUPT_i2c_slave_callback(enum I2CHandle handle, enum I2CSlaveEvent event, u8* data)
    {
        panic;
    }
#endif
#if TARGET_NAME_IS_DemoStepper
    static void
    INTERRUPT_i2c_slave_callback(enum I2CHandle handle, enum I2CSlaveEvent event, u8* data)
    {
        panic;
    }
#endif
