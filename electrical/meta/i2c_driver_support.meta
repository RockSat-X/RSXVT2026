#if TARGET_NAME_IS_SandboxNucleoH7S3L8
    #error Target "SandboxNucleoH7S3L8" cannot use the I2C driver without first specifying the peripheral instances to have handles for.
#endif
#if TARGET_NAME_IS_SandboxNucleoH533RE
    #error Target "SandboxNucleoH533RE" cannot use the I2C driver without first specifying the peripheral instances to have handles for.
#endif
#if TARGET_NAME_IS_DemoI2C
    enum I2CHandle : u32
    {
        I2CHandle_primary,
    };
    static constexpr u32 I2CHandle_COUNT = 1;
    #define I2Cx_ I2C_
    static const struct { typeof(I2C1) I2Cx; typeof(NVICInterrupt_I2C1_EV) NVICInterrupt_I2Cx_EV; typeof(NVICInterrupt_I2C1_ER) NVICInterrupt_I2Cx_ER; typeof(STPY_I2C1_KERNEL_SOURCE) STPY_I2Cx_KERNEL_SOURCE; typeof(STPY_I2C1_PRESC) STPY_I2Cx_PRESC; typeof(STPY_I2C1_SCLH) STPY_I2Cx_SCLH; typeof(STPY_I2C1_SCLL) STPY_I2Cx_SCLL; typeof((struct CMSISTuple) { &RCC->APB1LRSTR, CONCAT(RCC_, APB1LRSTR_I2C1RST_Pos), CONCAT(RCC_, APB1LRSTR_I2C1RST_Msk) }) I2Cx_RESET; typeof((struct CMSISTuple) { &RCC->APB1LENR, CONCAT(RCC_, APB1LENR_I2C1EN_Pos), CONCAT(RCC_, APB1LENR_I2C1EN_Msk) }) I2Cx_ENABLE; typeof((struct CMSISTuple) { &RCC->CCIPR4, CONCAT(RCC_, CCIPR4_I2C1SEL_Pos), CONCAT(RCC_, CCIPR4_I2C1SEL_Msk) }) I2Cx_KERNEL_SOURCE; } I2C_TABLE[] =
        {
            [I2CHandle_primary] = { .I2Cx = I2C1, .NVICInterrupt_I2Cx_EV = NVICInterrupt_I2C1_EV, .NVICInterrupt_I2Cx_ER = NVICInterrupt_I2C1_ER, .STPY_I2Cx_KERNEL_SOURCE = STPY_I2C1_KERNEL_SOURCE, .STPY_I2Cx_PRESC = STPY_I2C1_PRESC, .STPY_I2Cx_SCLH = STPY_I2C1_SCLH, .STPY_I2Cx_SCLL = STPY_I2C1_SCLL, .I2Cx_RESET = (struct CMSISTuple) { &RCC->APB1LRSTR, CONCAT(RCC_, APB1LRSTR_I2C1RST_Pos), CONCAT(RCC_, APB1LRSTR_I2C1RST_Msk) }, .I2Cx_ENABLE = (struct CMSISTuple) { &RCC->APB1LENR, CONCAT(RCC_, APB1LENR_I2C1EN_Pos), CONCAT(RCC_, APB1LENR_I2C1EN_Msk) }, .I2Cx_KERNEL_SOURCE = (struct CMSISTuple) { &RCC->CCIPR4, CONCAT(RCC_, CCIPR4_I2C1SEL_Pos), CONCAT(RCC_, CCIPR4_I2C1SEL_Msk) } },
        };
#endif
#if TARGET_NAME_IS_DemoTimer
    #error Target "DemoTimer" cannot use the I2C driver without first specifying the peripheral instances to have handles for.
#endif
#if TARGET_NAME_IS_DemoSPI
    #error Target "DemoSPI" cannot use the I2C driver without first specifying the peripheral instances to have handles for.
#endif
#if TARGET_NAME_IS_DemoTimekeeping
    #error Target "DemoTimekeeping" cannot use the I2C driver without first specifying the peripheral instances to have handles for.
#endif
#undef _EXPAND_HANDLE
#define _EXPAND_HANDLE\
    \
    if (!(0 <= handle && handle < I2CHandle_COUNT))\
    {\
        panic;\
    }\
    \
    struct I2CDriver* const driver = &_I2C_drivers[handle];\
    \
    auto const I2Cx = I2C_TABLE[handle].I2Cx;\
    auto const NVICInterrupt_I2Cx_EV = I2C_TABLE[handle].NVICInterrupt_I2Cx_EV;\
    auto const NVICInterrupt_I2Cx_ER = I2C_TABLE[handle].NVICInterrupt_I2Cx_ER;\
    auto const STPY_I2Cx_KERNEL_SOURCE = I2C_TABLE[handle].STPY_I2Cx_KERNEL_SOURCE;\
    auto const STPY_I2Cx_PRESC = I2C_TABLE[handle].STPY_I2Cx_PRESC;\
    auto const STPY_I2Cx_SCLH = I2C_TABLE[handle].STPY_I2Cx_SCLH;\
    auto const STPY_I2Cx_SCLL = I2C_TABLE[handle].STPY_I2Cx_SCLL;\
    auto const I2Cx_RESET = I2C_TABLE[handle].I2Cx_RESET;\
    auto const I2Cx_ENABLE = I2C_TABLE[handle].I2Cx_ENABLE;\
    auto const I2Cx_KERNEL_SOURCE = I2C_TABLE[handle].I2Cx_KERNEL_SOURCE;\

#if TARGET_NAME_IS_SandboxNucleoH7S3L8
#endif
#if TARGET_NAME_IS_SandboxNucleoH533RE
#endif
#if TARGET_NAME_IS_DemoI2C

    static void
    _I2C_update_entirely(enum I2CHandle handle);

    INTERRUPT_I2C1_EV
    {
        _I2C_update_entirely(I2CHandle_primary);
    }


    static void
    _I2C_update_entirely(enum I2CHandle handle);

    INTERRUPT_I2C1_ER
    {
        _I2C_update_entirely(I2CHandle_primary);
    }

#endif
#if TARGET_NAME_IS_DemoTimer
#endif
#if TARGET_NAME_IS_DemoSPI
#endif
#if TARGET_NAME_IS_DemoTimekeeping
#endif
