#if TARGET_NAME_IS_SandboxNucleoH7S3L8
    #error Target "SandboxNucleoH7S3L8" cannot use the I2C driver without first specifying the peripheral instances to have handles for.
#endif
#if TARGET_NAME_IS_SandboxNucleoH533RE
    #error Target "SandboxNucleoH533RE" cannot use the I2C driver without first specifying the peripheral instances to have handles for.
#endif
#if TARGET_NAME_IS_DemoI2C
    enum I2CHandle : u32
    {
        I2CHandle_primary,
    };
    static constexpr u32 I2CHandle_COUNT = 1;
    #define I2Cx_ I2C_
    static const struct { typeof(I2C1) I2Cx; typeof(NVICInterrupt_I2C1_EV) NVICInterrupt_I2Cx_EV; typeof(NVICInterrupt_I2C1_ER) NVICInterrupt_I2Cx_ER; typeof(I2C1_KERNEL_SOURCE_init) I2Cx_KERNEL_SOURCE_init; typeof(I2C1_TIMINGR_PRESC_init) I2Cx_TIMINGR_PRESC_init; typeof(I2C1_TIMINGR_SCL_init) I2Cx_TIMINGR_SCL_init; typeof((struct CMSISTuple) { &RCC->APB1LRSTR, RCC_APB1LRSTR_I2C1RST_Pos, RCC_APB1LRSTR_I2C1RST_Msk }) I2Cx_RESET; typeof((struct CMSISTuple) { &RCC->APB1LENR, RCC_APB1LENR_I2C1EN_Pos, RCC_APB1LENR_I2C1EN_Msk }) I2Cx_ENABLE; typeof((struct CMSISTuple) { &RCC->CCIPR4, RCC_CCIPR4_I2C1SEL_Pos, RCC_CCIPR4_I2C1SEL_Msk }) I2Cx_KERNEL_SOURCE; } I2C_TABLE[] =
        {
            [I2CHandle_primary] = { .I2Cx = I2C1, .NVICInterrupt_I2Cx_EV = NVICInterrupt_I2C1_EV, .NVICInterrupt_I2Cx_ER = NVICInterrupt_I2C1_ER, .I2Cx_KERNEL_SOURCE_init = I2C1_KERNEL_SOURCE_init, .I2Cx_TIMINGR_PRESC_init = I2C1_TIMINGR_PRESC_init, .I2Cx_TIMINGR_SCL_init = I2C1_TIMINGR_SCL_init, .I2Cx_RESET = (struct CMSISTuple) { &RCC->APB1LRSTR, RCC_APB1LRSTR_I2C1RST_Pos, RCC_APB1LRSTR_I2C1RST_Msk }, .I2Cx_ENABLE = (struct CMSISTuple) { &RCC->APB1LENR, RCC_APB1LENR_I2C1EN_Pos, RCC_APB1LENR_I2C1EN_Msk }, .I2Cx_KERNEL_SOURCE = (struct CMSISTuple) { &RCC->CCIPR4, RCC_CCIPR4_I2C1SEL_Pos, RCC_CCIPR4_I2C1SEL_Msk } },
        };
#endif
#if TARGET_NAME_IS_DemoTimer
    #error Target "DemoTimer" cannot use the I2C driver without first specifying the peripheral instances to have handles for.
#endif
#undef _EXPAND_HANDLE
#define _EXPAND_HANDLE\
    \
    if (!(0 <= handle && handle < I2CHandle_COUNT))\
    {\
        panic;\
    }\
    \
    struct I2CDriver* const driver = &_I2C_drivers[handle];\
    \
    auto const I2Cx = I2C_TABLE[handle].I2Cx;\
    auto const NVICInterrupt_I2Cx_EV = I2C_TABLE[handle].NVICInterrupt_I2Cx_EV;\
    auto const NVICInterrupt_I2Cx_ER = I2C_TABLE[handle].NVICInterrupt_I2Cx_ER;\
    auto const I2Cx_KERNEL_SOURCE_init = I2C_TABLE[handle].I2Cx_KERNEL_SOURCE_init;\
    auto const I2Cx_TIMINGR_PRESC_init = I2C_TABLE[handle].I2Cx_TIMINGR_PRESC_init;\
    auto const I2Cx_TIMINGR_SCL_init = I2C_TABLE[handle].I2Cx_TIMINGR_SCL_init;\
    auto const I2Cx_RESET = I2C_TABLE[handle].I2Cx_RESET;\
    auto const I2Cx_ENABLE = I2C_TABLE[handle].I2Cx_ENABLE;\
    auto const I2Cx_KERNEL_SOURCE = I2C_TABLE[handle].I2Cx_KERNEL_SOURCE;\


#if TARGET_NAME_IS_SandboxNucleoH7S3L8
#endif
#if TARGET_NAME_IS_SandboxNucleoH533RE
#endif
#if TARGET_NAME_IS_DemoI2C

    static void
    _I2C_update_entirely(enum I2CHandle handle);

    INTERRUPT_I2C1_EV
    {
        _I2C_update_entirely(I2CHandle_primary);
    }


    static void
    _I2C_update_entirely(enum I2CHandle handle);

    INTERRUPT_I2C1_ER
    {
        _I2C_update_entirely(I2CHandle_primary);
    }

#endif
#if TARGET_NAME_IS_DemoTimer
#endif
