#if TARGET_NAME_IS_SandboxNucleoH7S3L8
    #error Target 'SandboxNucleoH7S3L8' defines no handle for the 'Stepper' driver.
#endif
#if TARGET_NAME_IS_SandboxNucleoH533RE
    #error Target 'SandboxNucleoH533RE' defines no handle for the 'Stepper' driver.
#endif
#if TARGET_NAME_IS_DemoI2C
    #error Target 'DemoI2C' defines no handle for the 'Stepper' driver.
#endif
#if TARGET_NAME_IS_DemoTimer
    #error Target 'DemoTimer' defines no handle for the 'Stepper' driver.
#endif
#if TARGET_NAME_IS_DemoSPI
    #error Target 'DemoSPI' defines no handle for the 'Stepper' driver.
#endif
#if TARGET_NAME_IS_DemoTimekeeping
    #error Target 'DemoTimekeeping' defines no handle for the 'Stepper' driver.
#endif
#if TARGET_NAME_IS_DemoSDMMC
    #error Target 'DemoSDMMC' defines no handle for the 'Stepper' driver.
#endif
#if TARGET_NAME_IS_SensorShield
    #error Target 'SensorShield' defines no handle for the 'Stepper' driver.
#endif
#if TARGET_NAME_IS_MainFlightComputer
    #error Target 'MainFlightComputer' defines no handle for the 'Stepper' driver.
#endif
#if TARGET_NAME_IS_VehicleFlightComputer
    #error Target 'VehicleFlightComputer' defines no handle for the 'Stepper' driver.
#endif
#if TARGET_NAME_IS_DemoStepper
    enum StepperHandle : u32
    {
        StepperHandle_primary,
    };
    static constexpr u32 StepperHandle_COUNT = 1;
    #define TIMx_ TIM_
    static const struct { typeof(TIM1) TIMx; typeof(NVICInterrupt_TIM1_UP) NVICInterrupt_TIMx_update_event; typeof(STPY_TIM1_DIVIDER) STPY_TIMx_DIVIDER; typeof((struct CMSISTuple) { &RCC->APB2ENR, CONCAT(RCC_, APB2ENR_TIM1EN_Pos), CONCAT(RCC_, APB2ENR_TIM1EN_Msk) }) TIMx_ENABLE; typeof((struct CMSISTuple) { &TIM1->CCER, CONCAT(TIM1_, CCER_CC2E_Pos), CONCAT(TIM1_, CCER_CC2E_Msk) }) TIMx_CAPTURE_COMPARE_ENABLE_y; typeof((struct CMSISTuple) { &TIM1->CCR2, CONCAT(TIM1_, CCR2_CCR2_Pos), CONCAT(TIM1_, CCR2_CCR2_Msk) }) TIMx_CAPTURE_COMPARE_VALUE_y; typeof((struct CMSISTuple) { &TIM1->CCMR1, CONCAT(TIM1_, CCMR1_OC2M_Pos), CONCAT(TIM1_, CCMR1_OC2M_Msk) }) TIMx_CAPTURE_COMPARE_MODE_y; } STEPPER_TABLE[] =
        {
            [StepperHandle_primary] = { .TIMx = TIM1, .NVICInterrupt_TIMx_update_event = NVICInterrupt_TIM1_UP, .STPY_TIMx_DIVIDER = STPY_TIM1_DIVIDER, .TIMx_ENABLE = (struct CMSISTuple) { &RCC->APB2ENR, CONCAT(RCC_, APB2ENR_TIM1EN_Pos), CONCAT(RCC_, APB2ENR_TIM1EN_Msk) }, .TIMx_CAPTURE_COMPARE_ENABLE_y = (struct CMSISTuple) { &TIM1->CCER, CONCAT(TIM1_, CCER_CC2E_Pos), CONCAT(TIM1_, CCER_CC2E_Msk) }, .TIMx_CAPTURE_COMPARE_VALUE_y = (struct CMSISTuple) { &TIM1->CCR2, CONCAT(TIM1_, CCR2_CCR2_Pos), CONCAT(TIM1_, CCR2_CCR2_Msk) }, .TIMx_CAPTURE_COMPARE_MODE_y = (struct CMSISTuple) { &TIM1->CCMR1, CONCAT(TIM1_, CCMR1_OC2M_Pos), CONCAT(TIM1_, CCMR1_OC2M_Msk) } },
        };
    static void
    _STEPPER_driver_interrupt(enum StepperHandle handle);
    INTERRUPT_TIM1_UP
    {
        _STEPPER_driver_interrupt(StepperHandle_primary);
    }
#endif
#if TARGET_NAME_IS_DemoOVCAM
    #error Target 'DemoOVCAM' defines no handle for the 'Stepper' driver.
#endif
#undef _EXPAND_HANDLE
#define _EXPAND_HANDLE\
    if (!(0 <= handle && handle < StepperHandle_COUNT))\
        panic;\
    auto const driver = &_STEPPER_drivers[handle];\
    auto const TIMx = STEPPER_TABLE[handle].TIMx;\
    auto const NVICInterrupt_TIMx_update_event = STEPPER_TABLE[handle].NVICInterrupt_TIMx_update_event;\
    auto const STPY_TIMx_DIVIDER = STEPPER_TABLE[handle].STPY_TIMx_DIVIDER;\
    auto const TIMx_ENABLE = STEPPER_TABLE[handle].TIMx_ENABLE;\
    auto const TIMx_CAPTURE_COMPARE_ENABLE_y = STEPPER_TABLE[handle].TIMx_CAPTURE_COMPARE_ENABLE_y;\
    auto const TIMx_CAPTURE_COMPARE_VALUE_y = STEPPER_TABLE[handle].TIMx_CAPTURE_COMPARE_VALUE_y;\
    auto const TIMx_CAPTURE_COMPARE_MODE_y = STEPPER_TABLE[handle].TIMx_CAPTURE_COMPARE_MODE_y;\

